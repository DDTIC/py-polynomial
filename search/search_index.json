{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python package defining single-variable polynomials and operations with them Installation pip3 install py-polynomial Sample functionality Flexible initialization >>> from polynomial import Polynomial >>> a = Polynomial ( 1 , 2 , 3 , 4 ) >>> str ( a ) x^3 + 2x^2 + 3x + 4 >>> b = Polynomial ([ 4 - x for x in range ( 4 )]) >>> str ( b ) 4x^3 + 3x^2 + 2x + 1 First derivative >>> b . derivative Polynomial(12, 6, 2) >>> str ( b . derivative ) 12x^2 + 6x + 2 Second or higher derivative >>> str ( b . nth_derivative ( 2 )) 24x + 6 Addition >>> str ( a + b ) 5x^3 + 5x^2 + 5x + 5 Calculating value for a given x >>> ( a + b ) . calculate ( 5 ) 780 Multiplication >>> p = Polynomial ( 1 , 2 ) * Polynomial ( 1 , 2 ) >>> p Polynomial(1, 4, 4) Accessing coefficient by degree >>> p [ 0 ] = - 4 >>> p Polynomial(1, 4, -4) Slicing >>> p [ 1 :] = [ 4 , - 1 ] >>> p Polynomial(-1, 4, -4) Accessing coefficients by name convention >>> ( p . a , p . b , p . c ) (-1, 4, -4) >>> p . a , p . c = 1 , 4 >>> ( p . A , p . B , p . C ) (1, 4, 4) Division and remainder >>> q , remainder = divmod ( p , Polynomial ( 1 , 2 )) >>> q Polynomial(1.0, 2.0) >>> remainder Polynomial() >>> p // Polynomial ( 1 , 2 ) Polynomial(1.0, 2.0) >>> P ( 1 , 2 , 3 ) % Polynomial ( 1 , 2 ) Polynomial(3) Check whether it contains given terms >>> Polynomial ( 2 , 1 ) in Polynomial ( 4 , 3 , 2 , 1 ) True Misc >>> str ( Polynomial ( \"abc\" )) ax^2 + bx + c Roots and discriminants >>> from polynomial import QuadraticTrinomial , Monomial >>> y = QuadraticTrinomial ( 1 , - 2 , 1 ) >>> str ( y ) x^2 - 2x + 1 >>> y . discriminant 0 >>> y . real_roots (1, 1) >>> y . real_factors (1, Polynomial(1, -1), Polynomial(1, -1)) >>> str ( Monomial ( 5 , 3 )) 5x^3 >>> y += Monomial ( 9 , 2 ) >>> y Polynomial(10, -2, 1) >>> str ( y ) 10x^2 - 2x + 1 >>> ( y . a , y . b , y . c ) (10, -2, 1) >>> ( y . A , y . B , y . C ) (10, -2, 1) >>> y . complex_roots ((0.1 + 0.3j), (0.1 - 0.3j))","title":"Home"},{"location":"#python-package-defining-single-variable-polynomials-and-operations-with-them","text":"","title":"Python package defining single-variable polynomials and operations with them"},{"location":"#installation","text":"pip3 install py-polynomial","title":"Installation"},{"location":"#sample-functionality","text":"","title":"Sample functionality"},{"location":"#flexible-initialization","text":">>> from polynomial import Polynomial >>> a = Polynomial ( 1 , 2 , 3 , 4 ) >>> str ( a ) x^3 + 2x^2 + 3x + 4 >>> b = Polynomial ([ 4 - x for x in range ( 4 )]) >>> str ( b ) 4x^3 + 3x^2 + 2x + 1","title":"Flexible initialization"},{"location":"#first-derivative","text":">>> b . derivative Polynomial(12, 6, 2) >>> str ( b . derivative ) 12x^2 + 6x + 2","title":"First derivative"},{"location":"#second-or-higher-derivative","text":">>> str ( b . nth_derivative ( 2 )) 24x + 6","title":"Second or higher derivative"},{"location":"#addition","text":">>> str ( a + b ) 5x^3 + 5x^2 + 5x + 5","title":"Addition"},{"location":"#calculating-value-for-a-given-x","text":">>> ( a + b ) . calculate ( 5 ) 780","title":"Calculating value for a given x"},{"location":"#multiplication","text":">>> p = Polynomial ( 1 , 2 ) * Polynomial ( 1 , 2 ) >>> p Polynomial(1, 4, 4)","title":"Multiplication"},{"location":"#accessing-coefficient-by-degree","text":">>> p [ 0 ] = - 4 >>> p Polynomial(1, 4, -4)","title":"Accessing coefficient by degree"},{"location":"#slicing","text":">>> p [ 1 :] = [ 4 , - 1 ] >>> p Polynomial(-1, 4, -4)","title":"Slicing"},{"location":"#accessing-coefficients-by-name-convention","text":">>> ( p . a , p . b , p . c ) (-1, 4, -4) >>> p . a , p . c = 1 , 4 >>> ( p . A , p . B , p . C ) (1, 4, 4)","title":"Accessing coefficients by name convention"},{"location":"#division-and-remainder","text":">>> q , remainder = divmod ( p , Polynomial ( 1 , 2 )) >>> q Polynomial(1.0, 2.0) >>> remainder Polynomial() >>> p // Polynomial ( 1 , 2 ) Polynomial(1.0, 2.0) >>> P ( 1 , 2 , 3 ) % Polynomial ( 1 , 2 ) Polynomial(3)","title":"Division and remainder"},{"location":"#check-whether-it-contains-given-terms","text":">>> Polynomial ( 2 , 1 ) in Polynomial ( 4 , 3 , 2 , 1 ) True","title":"Check whether it contains given terms"},{"location":"#misc","text":">>> str ( Polynomial ( \"abc\" )) ax^2 + bx + c","title":"Misc"},{"location":"#roots-and-discriminants","text":">>> from polynomial import QuadraticTrinomial , Monomial >>> y = QuadraticTrinomial ( 1 , - 2 , 1 ) >>> str ( y ) x^2 - 2x + 1 >>> y . discriminant 0 >>> y . real_roots (1, 1) >>> y . real_factors (1, Polynomial(1, -1), Polynomial(1, -1)) >>> str ( Monomial ( 5 , 3 )) 5x^3 >>> y += Monomial ( 9 , 2 ) >>> y Polynomial(10, -2, 1) >>> str ( y ) 10x^2 - 2x + 1 >>> ( y . a , y . b , y . c ) (10, -2, 1) >>> ( y . A , y . B , y . C ) (10, -2, 1) >>> y . complex_roots ((0.1 + 0.3j), (0.1 - 0.3j))","title":"Roots and discriminants"},{"location":"reference/polynomial/","text":"Module polynomial This module focuses on an exhaustive implementation of polynomials. (c) Yalishanda yalishanda@abv.bg View Source \"\"\"This module focuses on an exhaustive implementation of polynomials. (c) Yalishanda <yalishanda@abv.bg> \"\"\" from .core import ( Constant , PolynomialError , DegreeError , TermError , Monomial , Polynomial , ) from .frozen import FrozenPolynomial , ZeroPolynomial from .binomial import Binomial , LinearBinomial from .trinomial import Trinomial , QuadraticTrinomial Sub-modules polynomial.binomial polynomial.core polynomial.frozen polynomial.trinomial","title":"Index"},{"location":"reference/polynomial/#module-polynomial","text":"This module focuses on an exhaustive implementation of polynomials. (c) Yalishanda yalishanda@abv.bg View Source \"\"\"This module focuses on an exhaustive implementation of polynomials. (c) Yalishanda <yalishanda@abv.bg> \"\"\" from .core import ( Constant , PolynomialError , DegreeError , TermError , Monomial , Polynomial , ) from .frozen import FrozenPolynomial , ZeroPolynomial from .binomial import Binomial , LinearBinomial from .trinomial import Trinomial , QuadraticTrinomial","title":"Module polynomial"},{"location":"reference/polynomial/#sub-modules","text":"polynomial.binomial polynomial.core polynomial.frozen polynomial.trinomial","title":"Sub-modules"},{"location":"reference/polynomial/binomial/","text":"Module polynomial.binomial This module defines different types of binomials and their methods. View Source \"\"\"This module defines different types of binomials and their methods.\"\"\" from polynomial.core import ( Polynomial , Monomial , FixedDegreePolynomial , FixedTermPolynomial ) class Binomial ( FixedTermPolynomial , valid_term_counts = ( 0 , 1 , 2 )): \"\"\"Implements single-variable mathematical binomials.\"\"\" def __init__ ( self , monomial1 = None , monomial2 = None ): \"\"\"Initialize the binomial with 2 monomials. The arguments can also be 2-tuples in the form: (coefficient, degree) \"\"\" if not monomial1 : monomial1 = Monomial ( 1 , 1 ) if not monomial2 : monomial2 = Monomial ( 1 , 2 ) Polynomial . __init__ ( self , [ monomial1 , monomial2 ], from_monomials = True ) def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" terms = self . terms assert len ( terms ) == 2 t1 , t2 = terms return ( \"Binomial(Monomial({0}, {1}), Monomial({2}, {3}))\" . format ( * t1 , * t2 ) ) class LinearBinomial ( FixedDegreePolynomial , Binomial , valid_degrees = 1 ): \"\"\"Implements linear binomials and their methods.\"\"\" def __init__ ( self , a = 1 , b = 1 ): \"\"\"Initialize the binomial as ax + b.\"\"\" if a == 0 : raise ValueError ( \"object not a linear binomial since a = 0!\" ) Polynomial . __init__ ( self , [ a , b ]) @property def root ( self ): \"\"\"Solve for ax + b = 0.\"\"\" return - self . b / self . a def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" return \"LinearBinomial({0!r}, {1!r})\" . format ( self . a , self . b ) Classes Binomial class Binomial ( monomial1 = None , monomial2 = None ) Implements single-variable mathematical binomials. View Source class Binomial ( FixedTermPolynomial , valid_term_counts = ( 0 , 1 , 2 )): \"\"\"Implements single-variable mathematical binomials.\"\"\" def __init__ ( self , monomial1 = None , monomial2 = None ): \"\"\"Initialize the binomial with 2 monomials. The arguments can also be 2-tuples in the form: (coefficient, degree) \"\"\" if not monomial1 : monomial1 = Monomial ( 1 , 1 ) if not monomial2 : monomial2 = Monomial ( 1 , 2 ) Polynomial . __init__ ( self , [ monomial1 , monomial2 ], from_monomials = True ) def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" terms = self . terms assert len ( terms ) == 2 t1 , t2 = terms return ( \"Binomial(Monomial({0}, {1}), Monomial({2}, {3}))\" . format ( * t1 , * t2 ) ) Ancestors (in MRO) polynomial.core.FixedTermPolynomial polynomial.core.Polynomial Descendants polynomial.binomial.LinearBinomial Class variables valid_term_counts Static methods zero_instance def zero_instance ( ) Return the Polynomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial () Instance variables degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. Methods calculate def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms ) nth_derivative def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] ) terms_are_valid def terms_are_valid ( self , terms ) View Source def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) ) try_set_self def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True ) LinearBinomial class LinearBinomial ( a = 1 , b = 1 ) Implements linear binomials and their methods. View Source class LinearBinomial ( FixedDegreePolynomial , Binomial , valid_degrees = 1 ) : \"\"\"Implements linear binomials and their methods.\"\"\" def __init__ ( self , a = 1 , b = 1 ) : \"\"\"Initialize the binomial as ax + b.\"\"\" if a == 0 : raise ValueError ( \"object not a linear binomial since a = 0!\" ) Polynomial . __init__ ( self , [ a, b ] ) @property def root ( self ) : \"\"\"Solve for ax + b = 0.\"\"\" return - self . b / self . a def __repr__ ( self ) : \"\"\"Return repr(self).\"\"\" return \"LinearBinomial({0!r}, {1!r})\" . format ( self . a , self . b ) Ancestors (in MRO) polynomial.core.FixedDegreePolynomial polynomial.binomial.Binomial polynomial.core.FixedTermPolynomial polynomial.core.Polynomial Class variables valid_degrees valid_term_counts Static methods zero_instance def zero_instance ( ) Return the Polynomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial () Instance variables degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. root Solve for ax + b = 0. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. Methods calculate def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms ) nth_derivative def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] ) terms_are_valid def terms_are_valid ( self , terms ) View Source def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) ) try_set_self def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True )","title":"Binomial"},{"location":"reference/polynomial/binomial/#module-polynomialbinomial","text":"This module defines different types of binomials and their methods. View Source \"\"\"This module defines different types of binomials and their methods.\"\"\" from polynomial.core import ( Polynomial , Monomial , FixedDegreePolynomial , FixedTermPolynomial ) class Binomial ( FixedTermPolynomial , valid_term_counts = ( 0 , 1 , 2 )): \"\"\"Implements single-variable mathematical binomials.\"\"\" def __init__ ( self , monomial1 = None , monomial2 = None ): \"\"\"Initialize the binomial with 2 monomials. The arguments can also be 2-tuples in the form: (coefficient, degree) \"\"\" if not monomial1 : monomial1 = Monomial ( 1 , 1 ) if not monomial2 : monomial2 = Monomial ( 1 , 2 ) Polynomial . __init__ ( self , [ monomial1 , monomial2 ], from_monomials = True ) def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" terms = self . terms assert len ( terms ) == 2 t1 , t2 = terms return ( \"Binomial(Monomial({0}, {1}), Monomial({2}, {3}))\" . format ( * t1 , * t2 ) ) class LinearBinomial ( FixedDegreePolynomial , Binomial , valid_degrees = 1 ): \"\"\"Implements linear binomials and their methods.\"\"\" def __init__ ( self , a = 1 , b = 1 ): \"\"\"Initialize the binomial as ax + b.\"\"\" if a == 0 : raise ValueError ( \"object not a linear binomial since a = 0!\" ) Polynomial . __init__ ( self , [ a , b ]) @property def root ( self ): \"\"\"Solve for ax + b = 0.\"\"\" return - self . b / self . a def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" return \"LinearBinomial({0!r}, {1!r})\" . format ( self . a , self . b )","title":"Module polynomial.binomial"},{"location":"reference/polynomial/binomial/#classes","text":"","title":"Classes"},{"location":"reference/polynomial/binomial/#binomial","text":"class Binomial ( monomial1 = None , monomial2 = None ) Implements single-variable mathematical binomials. View Source class Binomial ( FixedTermPolynomial , valid_term_counts = ( 0 , 1 , 2 )): \"\"\"Implements single-variable mathematical binomials.\"\"\" def __init__ ( self , monomial1 = None , monomial2 = None ): \"\"\"Initialize the binomial with 2 monomials. The arguments can also be 2-tuples in the form: (coefficient, degree) \"\"\" if not monomial1 : monomial1 = Monomial ( 1 , 1 ) if not monomial2 : monomial2 = Monomial ( 1 , 2 ) Polynomial . __init__ ( self , [ monomial1 , monomial2 ], from_monomials = True ) def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" terms = self . terms assert len ( terms ) == 2 t1 , t2 = terms return ( \"Binomial(Monomial({0}, {1}), Monomial({2}, {3}))\" . format ( * t1 , * t2 ) )","title":"Binomial"},{"location":"reference/polynomial/binomial/#ancestors-in-mro","text":"polynomial.core.FixedTermPolynomial polynomial.core.Polynomial","title":"Ancestors (in MRO)"},{"location":"reference/polynomial/binomial/#descendants","text":"polynomial.binomial.LinearBinomial","title":"Descendants"},{"location":"reference/polynomial/binomial/#class-variables","text":"valid_term_counts","title":"Class variables"},{"location":"reference/polynomial/binomial/#static-methods","text":"","title":"Static methods"},{"location":"reference/polynomial/binomial/#zero_instance","text":"def zero_instance ( ) Return the Polynomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial ()","title":"zero_instance"},{"location":"reference/polynomial/binomial/#instance-variables","text":"degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient.","title":"Instance variables"},{"location":"reference/polynomial/binomial/#methods","text":"","title":"Methods"},{"location":"reference/polynomial/binomial/#calculate","text":"def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms )","title":"calculate"},{"location":"reference/polynomial/binomial/#nth_derivative","text":"def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] )","title":"nth_derivative"},{"location":"reference/polynomial/binomial/#terms_are_valid","text":"def terms_are_valid ( self , terms ) View Source def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) )","title":"terms_are_valid"},{"location":"reference/polynomial/binomial/#try_set_self","text":"def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True )","title":"try_set_self"},{"location":"reference/polynomial/binomial/#linearbinomial","text":"class LinearBinomial ( a = 1 , b = 1 ) Implements linear binomials and their methods. View Source class LinearBinomial ( FixedDegreePolynomial , Binomial , valid_degrees = 1 ) : \"\"\"Implements linear binomials and their methods.\"\"\" def __init__ ( self , a = 1 , b = 1 ) : \"\"\"Initialize the binomial as ax + b.\"\"\" if a == 0 : raise ValueError ( \"object not a linear binomial since a = 0!\" ) Polynomial . __init__ ( self , [ a, b ] ) @property def root ( self ) : \"\"\"Solve for ax + b = 0.\"\"\" return - self . b / self . a def __repr__ ( self ) : \"\"\"Return repr(self).\"\"\" return \"LinearBinomial({0!r}, {1!r})\" . format ( self . a , self . b )","title":"LinearBinomial"},{"location":"reference/polynomial/binomial/#ancestors-in-mro_1","text":"polynomial.core.FixedDegreePolynomial polynomial.binomial.Binomial polynomial.core.FixedTermPolynomial polynomial.core.Polynomial","title":"Ancestors (in MRO)"},{"location":"reference/polynomial/binomial/#class-variables_1","text":"valid_degrees valid_term_counts","title":"Class variables"},{"location":"reference/polynomial/binomial/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/polynomial/binomial/#zero_instance_1","text":"def zero_instance ( ) Return the Polynomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial ()","title":"zero_instance"},{"location":"reference/polynomial/binomial/#instance-variables_1","text":"degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. root Solve for ax + b = 0. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient.","title":"Instance variables"},{"location":"reference/polynomial/binomial/#methods_1","text":"","title":"Methods"},{"location":"reference/polynomial/binomial/#calculate_1","text":"def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms )","title":"calculate"},{"location":"reference/polynomial/binomial/#nth_derivative_1","text":"def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] )","title":"nth_derivative"},{"location":"reference/polynomial/binomial/#terms_are_valid_1","text":"def terms_are_valid ( self , terms ) View Source def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) )","title":"terms_are_valid"},{"location":"reference/polynomial/binomial/#try_set_self_1","text":"def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True )","title":"try_set_self"},{"location":"reference/polynomial/core/","text":"Module polynomial.core This module defines mutable polynomials, monomials and constants. View Source \"\"\"This module defines mutable polynomials, monomials and constants.\"\"\" from copy import deepcopy from itertools import chain from math import inf import string class PolynomialError ( Exception ) : \"\"\"Raised when a Polynomial encounters an error.\"\"\" class DegreeError ( PolynomialError ) : \"\"\"Raised when a Polynomial's degree changes.\"\"\" class TermError ( PolynomialError ) : \"\"\"Raised when a Polynomial's term count changes.\"\"\" def _ accepts_many_arguments ( function ) : \"\"\"Make a function that accepts an iterable handle many *args.\"\"\" def decorated ( self , * args , **kwargs ) : if len ( args ) == 1 and not isinstance ( args [ 0 ], ( int , float , complex )) : function ( self , args [ 0 ], kwargs ) else : function ( self , args , kwargs ) return decorated def _ extract_polynomial ( method ) : \"\"\"Call method with the second argument as a Polynomial. If casting is not possible or not appropriate, raise a ValueError. \"\"\" def decorated ( self , other ) : if isinstance ( other , Polynomial ) : return method ( self , other ) if isinstance ( other , ( int , float , complex )) : return method ( self , Constant ( other )) raise ValueError ( \"{0}.{1} requires a Polynomial or number, got {2}.\" . format ( self . __ class__ . __ name__ , method . __ name__ , type ( other ). __ name__ ) ) return decorated def _ get_more_permissive_class ( a , b ) : \"\"\"Return the most permissive class of a, b.\"\"\" a_cls = a . __ class__ b_cls = b . __ class__ return b_cls if issubclass ( a_cls , b_cls ) else a_cls def _ trim ( _ vector ) : \"\"\"Return _vector with all trailing zeros removed.\"\"\" if not _ vector or len ( _ vector ) == 1 : return _ vector ind = len ( _ vector ) while _ vector [ ind - 1 ] == 0 and ind > 0 : ind -= 1 return _ vector [ :ind ] def _ to_terms ( vec ) : \"\"\"Take a list of numbers and return the tuple form.\"\"\" s_d = _ degree ( vec , tuples = False ) return [( coeff , s_d - deg ) for deg , coeff in enumerate ( reversed ( vec )) if coeff ! = 0 ] def _ degree ( vec , tuples = True ) : \"\"\"Return the degree of vec.\"\"\" if not vec : return - inf if tuples : return max ( vec , key = lambda term : term [ 1 ] if term [ 0 ] else - inf )[ 1 ] return len ( vec ) - 1 def _ mul ( lhs , rhs ) : \"\"\"Return lhs * rhs.\"\"\" if not lhs or not rhs : return [( 0 , 0 )] deg = _ degree ( lhs ) + _ degree ( rhs ) + 1 res = [ 0 ] * deg for lcoeff , ldeg in lhs : for rcoeff , rdeg in rhs : res [ ldeg + rdeg ] += lcoeff * rcoeff return _ to_terms ( res ) def _ add ( lhs , rhs ) : \"\"\"Return lhs + rhs.\"\"\" if not lhs : return rhs if not rhs : return lhs deg = max ( _ degree ( lhs ), _ degree ( rhs )) + 1 res = [ 0 ] * deg for coeff , deg in chain ( lhs , rhs ) : res [ deg ] += coeff return _ to_terms ( res ) def _ neg ( vec ) : \"\"\"Return -vec.\"\"\" return [( - coeff , deg ) for coeff , deg in vec ] def _ sub ( lhs , rhs ) : \"\"\"Return lhs - rhs.\"\"\" if not lhs : return _ neg ( rhs ) if not rhs : return lhs deg = max ( _ degree ( lhs ), _ degree ( rhs )) + 1 res = [ 0 ] * deg for coeff , deg in lhs : res [ deg ] += coeff for coeff , deg in rhs : res [ deg ] -= coeff return _ to_terms ( res ) class Polynomial : \"\"\"Implements a single-variable mathematical polynomial.\"\"\" @ _ accepts_many_arguments def __ init__ ( self , iterable , from_monomials = False ) : \"\"\"Initialize the polynomial. iterable ::= the coefficients from the highest degree term to the lowest. The method is decorated so that it can accept many *args which it automatically transforms into a single iterable. If the from_monomials flag is True then it can accept many monomials or a single iterable with monomials which altogether add up to form this polynomial. Example usage: Polynomial([1,2,3,4,5]) Polynomial(1,2,3,4,5) Polynomial(range(1, 6)) Polynomial([(1,4), (2,3), (3,2), (4,1), (5,0)], from_monomials=True) Polynomial(((i + 1, 4 - i) for i in range(5)), from_monomials=True) \"\"\" if from_monomials: def monomial_to_tuple ( monomial ) : if isinstance ( monomial , Monomial ) : return monomial . a , monomial . degree if len ( monomial ) == 2 : return monomial raise TypeError ( \"{} cannot be a monomial.\" . format ( monomial )) self . terms = [ monomial_to_tuple ( monomial ) for monomial in iterable ] else : self . _ vector = _ trim ( list ( iterable )[ ::- 1 ]) @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial () def _ trim ( self ) : \"\"\"Trims self._vector to length. Keeps constant terms.\"\"\" self . _ vector = _ trim ( self . _ vector ) @property def degree ( self ) : \"\"\"Return the degree of the polynomial.\"\"\" if not self : return - inf # the degree of the zero polynomial is - infinity return len ( self . _ vector ) - 1 @property def derivative ( self ) : \"\"\"Return a polynomial object which is the derivative of self.\"\"\" return self . nth_derivative () def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c , x in zip ( self , reversed ( factors ))] ) @property def terms ( self ) : \"\"\"Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. \"\"\" s_d = self . degree return [( coeff , s_d - deg ) for deg , coeff in enumerate ( self ) if coeff ! = 0 ] @terms . setter def terms ( self , terms ) : \"\"\"Set the terms of self as a list of tuples in coeff, deg form.\"\"\" if not terms : _ vector = [ 0 ] else : list_len = max ( terms , key = lambda x : x [ 1 ])[ 1 ] + 1 _ vector = [ 0 ] * list_len for coeff , deg in terms : _ vector [ deg ] += coeff _ vector = _ trim ( _ vector ) self . _ vector = _ vector @property def monomials ( self ) : \"\"\"Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. \"\"\" return [ Monomial ( k , deg ) for k , deg in self . terms ] def calculate ( self , x ) : \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms ) def __ getattr__ ( self , name ) : \"\"\"Get coefficient by letter name: ax^n + bx^{n-1} + ... + yx + z.\"\"\" if len ( name ) ! = 1 : return object . __ getattribute__ ( self , name ) if name in string . ascii_letters: return self [ self . degree - ord ( name . lower ()) + ord ( 'a' )] raise AttributeError ( \"attribute {0} is not defined for Polynomial.\" . format ( name )) def __ setattr__ ( self , name , new_value ) : \"\"\"Set coefficient by letter name: ax^n + bx^{n-1} + ... + yx + z.\"\"\" if len ( name ) ! = 1 : object . __ setattr__ ( self , name , new_value ) elif name in string . ascii_letters: self [ self . degree - ord ( name . lower ()) + ord ( 'a' )] = new_value else : raise AttributeError ( \"attribute {0} is not defined for Polynomial.\" . format ( name )) def __ getitem__ ( self , degree ) : \"\"\"Get the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : return self . _ vector [ degree ] if degree == - inf and self . degree == - inf : return 0 if degree > self . degree or degree < 0 : raise IndexError ( \"Attempt to get coefficient of term with \\ degree {0} of a {1}-degree polynomial\" . format ( degree , self . degree )) return self . _ vector [ degree ] def __ setitem__ ( self , degree , new_value ) : \"\"\"Set the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : self . _ vector [ degree ] = new_value elif degree == - inf : if self . degree == - inf : self . _ vector = [ new_value ] else : raise IndexError ( \"Can not set term with degree -inf on a\" \" non-zero polynomial.\" ) elif degree > self . degree : raise IndexError ( \"Attempt to set coefficient of term with \\ degree {0} of a {1}-degree polynomial\" . format ( degree , self . degree )) else : self . _ vector [ degree ] = new_value self . _ trim () def __ iter__ ( self ) : \"\"\"Return the coefficients from the highest degree to the lowest.\"\"\" return reversed ( self . _ vector ) def __ repr__ ( self ) : \"\"\"Return repr(self).\"\"\" if not self : return \"Polynomial()\" terms = ', ' . join ([ repr ( ak ) for ak in self ]) return \"Polynomial({0})\" . format ( terms ) def __ str__ ( self ) : \"\"\"Return str(self).\"\"\" if not self : return \"0\" def components ( ak , k , is_leading ) : ak = str ( ak ) if ak [ 0 ] == \"-\" : # Strip - from ak ak = ak [ 1 : ] sign = \"-\" if is_leading else \"- \" else : sign = \"\" if is_leading else \"+ \" # if ak is 1 , the 1 is implicit when raising x to non - zero k , # so strip it . ak = \"\" if ak == \"1\" and k ! = 0 else ak # set x^k portion . if k == 0 : p , k = \"\" , \"\" elif k == 1 : p , k = \"x\" , \"\" else : p = \"x^\" return sign , ak , p , k # 0 : sign , 1 : coeff , 2 : x^ , 3 : a # eg . - 5 x^ 2 s_d = self . degree terms = [ \"{0}{1}{2}{3}\" . format ( * components ( ak , k , k == s_d )) for ak , k in self . terms ] return \" \" . join ( terms ) @ _ extract_polynomial def __ eq__ ( self , other ) : \"\"\"Return self == other. self == 0 <==> self == Polynomial() \"\"\" if other == 0 : return not self return self . degree == other . degree and self . terms == other . terms @ _ extract_polynomial def __ ne__ ( self , other ) : \"\"\"Return self != other. self != 0 <==> self != Polynomial() \"\"\" if other == 0 : return bool ( self ) return self . degree ! = other . degree or self . terms ! = other . terms def __ bool__ ( self ) : \"\"\"Return True if self is not a zero polynomial, otherwise False.\"\"\" self . _ trim () if not self . _ vector : return False if len ( self . _ vector ) > 1 : return True return self . _ vector [ 0 ] ! = 0 @ _ extract_polynomial def __ add__ ( self , other ) : \"\"\"Return self + other.\"\"\" if not self : return deepcopy ( other ) if not other : return deepcopy ( self ) return self . __ class__ (). try_set_self ( _ add ( self . terms , other . terms ) ) @ _ extract_polynomial def __ radd__ ( self , other ) : \"\"\"Return other + self.\"\"\" return self + other @ _ extract_polynomial def __ iadd__ ( self , other ) : \"\"\"Implement self += other.\"\"\" return self . try_set_self ( _ add ( self . terms , other . terms )) @ _ extract_polynomial def __ mul__ ( self , other ) : \"\"\"Return self * other.\"\"\" if not self or not other : return _ get_more_permissive_class ( self , other ). zero_instance () ret_val = deepcopy ( self ) ret_val *= other return ret_val @ _ extract_polynomial def __ rmul__ ( self , other ) : \"\"\"Return other * self.\"\"\" return self * other @ _ extract_polynomial def __ imul__ ( self , other ) : \"\"\"Implement self *= other.\"\"\" return self . try_set_self ( _ mul ( self . terms , other . terms )) def __ pos__ ( self ) : \"\"\"Return +self.\"\"\" self . _ trim () return deepcopy ( self ) def __ neg__ ( self ) : \"\"\"Return -self.\"\"\" ret_val = deepcopy ( self ) ret_val . _ vector = [ - x for x in _ trim ( self . _ vector )] return ret_val @ _ extract_polynomial def __ sub__ ( self , other ) : \"\"\"Return self - other.\"\"\" return self + ( - other ) @ _ extract_polynomial def __ rsub__ ( self , other ) : \"\"\"Return other - self.\"\"\" return other + ( - self ) @ _ extract_polynomial def __ isub__ ( self , other ) : \"\"\"Implement self -= other.\"\"\" return self . try_set_self ( _ sub ( self . terms , other . terms )) @ _ extract_polynomial def __ ifloordiv__ ( self , other ) : \"\"\"Return self //= other.\"\"\" return self . try_set_self ( divmod ( self , other )[ 0 ]. terms ) @ _ extract_polynomial def __ floordiv__ ( self , other ) : \"\"\"Return self // other.\"\"\" return divmod ( self , other )[ 0 ] @ _ extract_polynomial def __ imod__ ( self , other ) : \"\"\"Return self %= other.\"\"\" return self . try_set_self ( divmod ( self , other )[ 1 ]. terms ) @ _ extract_polynomial def __ mod__ ( self , other ) : \"\"\"Return self % other.\"\"\" return divmod ( self , other )[ 1 ] @ _ extract_polynomial def __ divmod__ ( self , other ) : \"\"\"Return divmod(self, other). The remainder is any term that would have degree < 0. \"\"\" if other . degree == - inf : raise ZeroDivisionError ( \"Can't divide a Polynomial by 0\" ) if isinstance ( other , Monomial ) : vec = self . _ vector [ other . degree :] remainder = self . _ vector [ :other . degree ] for i , v in enumerate ( vec ) : vec [ i ] = v / other . a return Polynomial ( vec [ ::- 1 ]), Polynomial ( remainder [ ::- 1 ]) working = self . terms wd0 = _ degree ( working ) other_terms = other . terms other_deg = other . degree vec = [] while wd0 >= other_deg: val = working [ 0 ][ 0 ] / other . a wd = wd0 working = _ sub ( working , _ mul ( other_terms , [( val , wd - other_deg )])) wd0 = _ degree ( working ) vec . append (( val , wd - other_deg if wd0 ! = - inf else 0 )) return ( Polynomial ( vec , from_monomials = True ), Polynomial ( working , from_monomials = True ) ) def __ pow__ ( self , power , modulo = None ) : \"\"\"Return self ** power or pow(self, other, modulo).\"\"\" if not isinstance ( power , int ) : raise ValueError ( \"Can't call Polynomial() ** x with a non-integer type.\" ) if power < 0 : raise ValueError ( \"Polynomial can only be raised to a non-negative power.\" ) if power == 0 : result = Constant ( 1 ) elif power % 2 == 1: result = Polynomial ( self ) if power > 1 : result *= ( self ** ( power // 2 )) ** 2 else : if power == 2 : result = Polynomial ( self ) else : result = self ** ( power // 2 ) result *= result return result % modulo if modulo is not None else result def __ ipow__ ( self , other ) : \"\"\"Return self **= power.\"\"\" terms = ( self ** other ). terms return self . try_set_self ( terms ) def __ lshift__ ( self , other ) : \"\"\"Return self << other. Increases the degree of each term by other. \"\"\" ret = deepcopy ( self ) ret <<= other return ret def __ ilshift__ ( self , other ) : \"\"\"Return self <<= other. Increases the degree of each term by other. \"\"\" if other < 0 : self >>= - other else : self . _ vector = [ 0 ] * other + self . _ vector return self def __ rshift__ ( self , other ) : \"\"\"Return self >> other. Decreases the degree of each term by other. \"\"\" ret = deepcopy ( self ) ret >>= other return ret def __ irshift__ ( self , other ) : \"\"\"Return self >>= other. Decreases the degree of each term by other. \"\"\" if other < 0 : self <<= - other else : self . _ vector = _ trim ( self . _ vector [ other :]) return self def __ contains__ ( self , item ) : \"\"\"Return item in self. Requires item to be a tuple, list of tuples, a set of tuples, or a Polynomial. Each tuple should contain two values, the first being the coefficient and the second being the degree. \"\"\" if isinstance ( item , tuple ) : return item in self . terms if isinstance ( item , list ) : return set ( item ). issubset ( self . terms ) if isinstance ( item , set ) : return item . issubset ( self . terms ) if isinstance ( item , Polynomial ) : return set ( item . terms ). issubset ( self . terms ) raise ValueError ( \"Can not check {0} for membership. A two-tuple, list of \" \"two-tuples, a set, or a Polynomial are required.\" . format ( type ( item ). __ name__ ) ) def terms_are_valid ( self , terms ) : \"\"\"Return true if the terms are valid.\"\"\" return True def try_set_self ( self , terms ) : \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ) : self . terms = terms return self return Polynomial ( terms , from_monomials = True ) def _ setvalue_decorator ( error , _ terms_are_valid , _ fn ) : \"\"\"Decorate __setattr__, checking if self._vector is still valid.\"\"\" def method ( self , name , new_value ) : _ fn ( self , name , new_value ) if ( name == '_vector' and not _ terms_are_valid ( self , _ to_terms ( self . _ vector ))) : raise error return method class FixedDegreePolynomial ( Polynomial ) : \"\"\"This Polynomial must maintain its degree.\"\"\" def __ init_subclass__ ( cls , **kwargs ) : \"\"\"Init a subclass of self.\"\"\" deg = kwargs [ \"valid_degrees\" ] if not isinstance ( deg , tuple ) : deg = ( deg ,) cls . valid_degrees = deg orig_terms_are_valid = cls . terms_are_valid def _ terms_are_valid ( self , terms ) : return _ degree ( terms ) in self . valid_degrees def terms_are_valid ( self , terms ) : return ( _ terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) ) cls . terms_are_valid = terms_are_valid cls . __ setattr__ = _ setvalue_decorator ( DegreeError , _ terms_are_valid , cls . __ setattr__ ) class FixedTermPolynomial ( Polynomial ) : \"\"\"This Polynomial must maintain the number of terms.\"\"\" def __ init_subclass__ ( cls , **kwargs ) : \"\"\"Init a subclass of self. Expects valid_term_counts to be provided as a tuple. \"\"\" cls . valid_term_counts = kwargs [ \"valid_term_counts\" ] orig_terms_are_valid = cls . terms_are_valid # Check that number of terms is correct . def _ terms_are_valid ( self , terms ) : return len ( terms ) in self . valid_term_counts def terms_are_valid ( self , terms ) : return ( _ terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) ) cls . terms_are_valid = terms_are_valid cls . __ setattr__ = _ setvalue_decorator ( TermError , _ terms_are_valid , cls . __ setattr__ ) class Monomial ( FixedTermPolynomial , valid_term_counts= ( 0 , 1 )) : \"\"\"Implements a single-variable monomial. A single-term polynomial.\"\"\" def __ init__ ( self , coefficient = 1 , degree = 1 ) : \"\"\"Initialize the following monomial: coefficient * x^(degree).\"\"\" if not isinstance ( degree , int ) : raise ValueError ( \"Monomial's degree should be a natural number.\" ) if degree < 0 : raise ValueError ( \"Polynomials cannot have negative-degree terms.\" ) self . _ degree = degree self . _ coeff = coefficient def _ trim ( self ) : \"\"\"Trims self._vector to length. Keeps constant terms.\"\"\" @property def terms ( self ) : \"\"\"Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. \"\"\" if self . _ coeff == 0 : return [( 0 , 0 )] return [( self . _ coeff , self . _ degree )] @terms . setter def terms ( self , terms ) : \"\"\"Set the terms of self as a list of tuples in coeff, deg form.\"\"\" if not terms : self . _ coeff = 0 elif len ( terms ) == 1 : self . _ coeff , self . _ degree = terms [ 0 ] else : terms = sorted ([ term for term in terms if term [ 0 ] ! = 0 ], key = lambda x : x [ 1 ]) if terms [ 0 ][ 1 ] == terms [ - 1 ][ 1 ] : self . _ coeff = sum ( term [ 0 ] for term in terms ) self . _ degree = terms [ 0 ][ 1 ] else : err_msg = \"terms has more than one non-zero term.\" curr_coeff , curr_deg = terms [ 0 ] termx = [] for coeff , deg in terms [ 1 : ] : if curr_deg == deg : curr_coeff += coeff else : if curr_coeff ! = 0 : if termx : raise TermError ( err_msg ) termx . append (( curr_coeff , curr_deg )) curr_coeff = coeff curr_deg = deg if termx : if curr_coeff: raise TermError ( err_msg ) self . _ coeff , self . _ degree = termx [ 0 ] else : self . _ coeff = curr_coeff self . _ degree = curr_deg @property def _ vector ( self ) : \"\"\"Get _vector.\"\"\" if self . degree == - inf : return [ 0 ] return [ 0 ] * self . _ degree + [ self . _ coeff ] @ _ vector . setter def _ vector ( self , _ vector ) : \"\"\"Set _vector.\"\"\" max_deg = len ( _ vector ) - 1 is_set = False for index , coeff in enumerate ( reversed ( _ vector )) : if coeff ! = 0 : if is_set: raise TermError ( \"_vector has > 1 non-zero term.\" ) self . _ coeff = coeff self . _ degree = max_deg - index is_set = True if not is_set: self . _ coeff = 0 @classmethod def zero_instance ( cls ) : \"\"\"Return the Monomial which is 0.\"\"\" return Monomial ( 0 , 0 ) @property def coefficient ( self ) : \"\"\"Return the coefficient of the monomial.\"\"\" return self . _ coeff @coefficient . setter def coefficient ( self , coeff ) : \"\"\"Set the coefficient of the monomial.\"\"\" self . _ coeff = coeff @property def degree ( self ) : \"\"\"Return the degree of the monomial.\"\"\" if self . _ coeff == 0 : self . _ degree = - inf elif self . _ degree == - inf : self . _ degree = 0 return self . _ degree @degree . setter def degree ( self , degree ) : \"\"\"Set the degree of the monomial.\"\"\" self . _ degree = degree @ _ extract_polynomial def __ mul__ ( self , other ) : \"\"\"Return self * other. The class which is more permissive will be returned. \"\"\" if isinstance ( other , Monomial ) and self and other : return Monomial ( self . coefficient * other . coefficient , self . degree + other . degree ) return super (). __ mul__ ( other ) @ _ extract_polynomial def __ rmul__ ( self , other ) : \"\"\"Return other * self. The class which is more permissive will be returned. \"\"\" return self * other def __ lt__ ( self , other ) : \"\"\"Return self < other. Compares the degrees of the monomials and then, if they are equal, compares their coefficients. \"\"\" if self . degree == other . degree : return self . a < other . a return self . degree < other . degree def __ gt__ ( self , other ) : \"\"\"Return self > other. Compares the degrees of the monomials and then, if they are equal, compares their coefficients. \"\"\" if self . degree == other . degree : return self . a > other . a return self . degree > other . degree def __ pow__ ( self , power , modulo = None ) : \"\"\"Return self ** power or pow(self, other, modulo).\"\"\" result = deepcopy ( self ) result **= power return result % modulo if modulo is not None else result def __ ipow__ ( self , other ) : \"\"\"Return self **= power. Assumes self is mutable. Does not mutate in the case that self == 0 and other != 1. \"\"\" if not isinstance ( other , int ) : raise ValueError ( \"Can't call Monomial() **= x with a non-integer type.\" ) if other < 0 : raise ValueError ( \"Monomial can only be raised to a non-negative power.\" ) if not self : if other ! = 0 : return self terms = [( 1 , 0 )] else : terms = [( self . coefficient ** other , self . degree * other )] # No native option exists to modify Monomial degree . return self . try_set_self ( terms ) def __ lshift__ ( self , other ) : \"\"\"Return self << other. Returns a Monomial that is self * x^other. \"\"\" if other < 0 : return self >> - other if not self : return self . zero_instance () return Monomial ( self . coefficient , self . degree + other ) def __ ilshift__ ( self , other ) : \"\"\"Return self <<= other. Returns a Monomial that is self * x^other. Does not guarantee the same type is returned. \"\"\" if other < 0 : self >>= - other return self if not self : return self return self . try_set_self ([( self . coefficient , self . degree + other )]) def __ irshift__ ( self , other ) : \"\"\"Return self >>= other.\"\"\" if other < 0 : self <<= - other return self if not self : return self if other > self . degree : return self . try_set_self ([( 0 , 0 )]) return self . try_set_self ([( self . coefficient , self . degree - other )]) def __ repr__ ( self ) : \"\"\"Return repr(self).\"\"\" deg = max ( 0 , self . degree ) return \"Monomial({0!r}, {1!r})\" . format ( self . coefficient , deg ) def __ getitem__ ( self , degree ) : \"\"\"Get the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : return self . _ vector [ degree ] if degree == self . degree : return self . _ coeff if degree > self . degree or degree < 0 : raise IndexError ( \"Attempt to get coefficient of term with \\ degree {0} of a {1}-degree monomial\" . format ( degree , self . degree )) return 0 def __ setitem__ ( self , degree , new_value ) : \"\"\"Set the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : _ vector = self . _ vector _ vector [ degree ] = new_value self . _ vector = _ vector elif degree == self . degree : self . coefficient = new_value else : raise TermError ( \"Can not set more than 1 term on Monomial.\" ) class Constant ( FixedDegreePolynomial , Monomial , valid_degrees= ( 0 , - inf )) : \"\"\"Implements constants as monomials of degree 0.\"\"\" def __ init__ ( self , const = 1 ) : \"\"\"Initialize the constant with value const.\"\"\" Monomial . __ init__ ( self , const , 0 ) @classmethod def zero_instance ( cls ) : \"\"\"Return the constant which is 0.\"\"\" return Constant ( 0 ) def __ eq__ ( self , other ) : \"\"\"Return self == other.\"\"\" if other == self . const : return True return super (). __ eq__ ( other ) @property def degree ( self ) : \"\"\"Return self.degree.\"\"\" return 0 if self . _ coeff else - inf @degree . setter def degree ( self , degree ) : \"\"\"Set self.degree.\"\"\" raise DegreeError ( \"Can't change the degree of Constant\" ) @property def const ( self ) : \"\"\"Return the constant term.\"\"\" return self . coefficient @const . setter def const ( self , val ) : \"\"\"Set the constant term.\"\"\" self . coefficient = val @ _ extract_polynomial def __ mul__ ( self , other ) : \"\"\"Return self * other.\"\"\" if isinstance ( other , Constant ) : return Constant ( self . const * other . const ) return super (). __ mul__ ( other ) def __ int__ ( self ) : \"\"\"Return int(self).\"\"\" return int ( self . const ) def __ float__ ( self ) : \"\"\"Return float(self).\"\"\" return float ( self . const ) def __ complex__ ( self ) : \"\"\"Return complex(self).\"\"\" return complex ( self . const ) def __ repr__ ( self ) : \"\"\"Return repr(self).\"\"\" return \"Constant({0!r})\" . format ( self . const ) Variables inf Classes Constant class Constant ( const = 1 ) Implements constants as monomials of degree 0. View Source class Constant ( FixedDegreePolynomial , Monomial , valid_degrees = ( 0 , - inf )): \"\"\"Implements constants as monomials of degree 0.\"\"\" def __init__ ( self , const = 1 ): \"\"\"Initialize the constant with value const.\"\"\" Monomial . __init__ ( self , const , 0 ) @ classmethod def zero_instance ( cls ): \"\"\"Return the constant which is 0.\"\"\" return Constant ( 0 ) def __eq__ ( self , other ): \"\"\"Return self == other.\"\"\" if other == self . const : return True return super () . __eq__ ( other ) @ property def degree ( self ): \"\"\"Return self.degree.\"\"\" return 0 if self . _coeff else - inf @ degree . setter def degree ( self , degree ): \"\"\"Set self.degree.\"\"\" raise DegreeError ( \"Can't change the degree of Constant\" ) @ property def const ( self ): \"\"\"Return the constant term.\"\"\" return self . coefficient @ const . setter def const ( self , val ): \"\"\"Set the constant term.\"\"\" self . coefficient = val @ _extract_polynomial def __mul__ ( self , other ): \"\"\"Return self * other.\"\"\" if isinstance ( other , Constant ): return Constant ( self . const * other . const ) return super () . __mul__ ( other ) def __int__ ( self ): \"\"\"Return int(self).\"\"\" return int ( self . const ) def __float__ ( self ): \"\"\"Return float(self).\"\"\" return float ( self . const ) def __complex__ ( self ): \"\"\"Return complex(self).\"\"\" return complex ( self . const ) def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" return \"Constant({0!r})\" . format ( self . const ) Ancestors (in MRO) polynomial.core.FixedDegreePolynomial polynomial.core.Monomial polynomial.core.FixedTermPolynomial polynomial.core.Polynomial Descendants polynomial.frozen.ZeroPolynomial Class variables valid_degrees valid_term_counts Static methods zero_instance def zero_instance ( ) Return the constant which is 0. View Source @ classmethod def zero_instance ( cls ): \"\"\"Return the constant which is 0.\"\"\" return Constant ( 0 ) Instance variables coefficient Return the coefficient of the monomial. const Return the constant term. degree Return self.degree. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. Methods calculate def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms ) nth_derivative def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] ) terms_are_valid def terms_are_valid ( self , terms ) View Source def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) ) try_set_self def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True ) DegreeError class DegreeError ( / , * args , ** kwargs ) Raised when a Polynomial's degree changes. View Source class DegreeError ( PolynomialError ): \"\"\"Raised when a Polynomial's degree changes.\"\"\" Ancestors (in MRO) polynomial.core.PolynomialError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. FixedDegreePolynomial class FixedDegreePolynomial ( * args , ** kwargs ) This Polynomial must maintain its degree. View Source class FixedDegreePolynomial ( Polynomial ): \"\"\"This Polynomial must maintain its degree.\"\"\" def __init_subclass__ ( cls , ** kwargs ): \"\"\"Init a subclass of self.\"\"\" deg = kwargs [ \"valid_degrees\" ] if not isinstance ( deg , tuple ): deg = ( deg ,) cls . valid_degrees = deg orig_terms_are_valid = cls . terms_are_valid def _terms_are_valid ( self , terms ): return _degree ( terms ) in self . valid_degrees def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) ) cls . terms_are_valid = terms_are_valid cls . __setattr__ = _setvalue_decorator ( DegreeError , _terms_are_valid , cls . __setattr__ ) Ancestors (in MRO) polynomial.core.Polynomial Descendants polynomial.core.Constant polynomial.binomial.LinearBinomial polynomial.trinomial.QuadraticTrinomial Static methods zero_instance def zero_instance ( ) Return the Polynomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial () Instance variables degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. Methods calculate def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms ) nth_derivative def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] ) terms_are_valid def terms_are_valid ( self , terms ) Return true if the terms are valid. View Source def terms_are_valid ( self , terms ): \"\"\"Return true if the terms are valid.\"\"\" return True try_set_self def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True ) FixedTermPolynomial class FixedTermPolynomial ( * args , ** kwargs ) This Polynomial must maintain the number of terms. View Source class FixedTermPolynomial ( Polynomial ): \"\"\"This Polynomial must maintain the number of terms.\"\"\" def __init_subclass__ ( cls , ** kwargs ): \"\"\"Init a subclass of self. Expects valid_term_counts to be provided as a tuple. \"\"\" cls . valid_term_counts = kwargs [ \"valid_term_counts\" ] orig_terms_are_valid = cls . terms_are_valid # Check that number of terms is correct. def _terms_are_valid ( self , terms ): return len ( terms ) in self . valid_term_counts def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) ) cls . terms_are_valid = terms_are_valid cls . __setattr__ = _setvalue_decorator ( TermError , _terms_are_valid , cls . __setattr__ ) Ancestors (in MRO) polynomial.core.Polynomial Descendants polynomial.core.Monomial polynomial.binomial.Binomial polynomial.trinomial.Trinomial Static methods zero_instance def zero_instance ( ) Return the Polynomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial () Instance variables degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. Methods calculate def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms ) nth_derivative def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] ) terms_are_valid def terms_are_valid ( self , terms ) Return true if the terms are valid. View Source def terms_are_valid ( self , terms ): \"\"\"Return true if the terms are valid.\"\"\" return True try_set_self def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True ) Monomial class Monomial ( coefficient = 1 , degree = 1 ) Implements a single-variable monomial. A single-term polynomial. View Source class Monomial ( FixedTermPolynomial , valid_term_counts = ( 0 , 1 )) : \"\"\"Implements a single-variable monomial. A single-term polynomial.\"\"\" def __init__ ( self , coefficient = 1 , degree = 1 ) : \"\"\"Initialize the following monomial: coefficient * x^(degree).\"\"\" if not isinstance ( degree , int ) : raise ValueError ( \"Monomial's degree should be a natural number.\" ) if degree < 0 : raise ValueError ( \"Polynomials cannot have negative-degree terms.\" ) self . _degree = degree self . _coeff = coefficient def _trim ( self ) : \"\"\"Trims self._vector to length. Keeps constant terms.\"\"\" @property def terms ( self ) : \"\"\"Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. \"\"\" if self . _coeff == 0 : return [ (0, 0) ] return [ (self._coeff, self._degree) ] @terms . setter def terms ( self , terms ) : \"\"\"Set the terms of self as a list of tuples in coeff, deg form.\"\"\" if not terms : self . _coeff = 0 elif len ( terms ) == 1 : self . _coeff , self . _degree = terms [ 0 ] else : terms = sorted ( [ term for term in terms if term[0 ] != 0 ] , key = lambda x : x [ 1 ] ) if terms [ 0 ][ 1 ] == terms [ -1 ][ 1 ] : self . _coeff = sum ( term [ 0 ] for term in terms ) self . _degree = terms [ 0 ][ 1 ] else : err_msg = \"terms has more than one non-zero term.\" curr_coeff , curr_deg = terms [ 0 ] termx = [] for coeff , deg in terms [ 1: ] : if curr_deg == deg : curr_coeff += coeff else : if curr_coeff != 0 : if termx : raise TermError ( err_msg ) termx . append (( curr_coeff , curr_deg )) curr_coeff = coeff curr_deg = deg if termx : if curr_coeff : raise TermError ( err_msg ) self . _coeff , self . _degree = termx [ 0 ] else : self . _coeff = curr_coeff self . _degree = curr_deg @property def _vector ( self ) : \"\"\"Get _vector.\"\"\" if self . degree == - inf : return [ 0 ] return [ 0 ] * self . _degree + [ self._coeff ] @_vector . setter def _vector ( self , _vector ) : \"\"\"Set _vector.\"\"\" max_deg = len ( _vector ) - 1 is_set = False for index , coeff in enumerate ( reversed ( _vector )) : if coeff != 0 : if is_set : raise TermError ( \"_vector has > 1 non-zero term.\" ) self . _coeff = coeff self . _degree = max_deg - index is_set = True if not is_set : self . _coeff = 0 @classmethod def zero_instance ( cls ) : \"\"\"Return the Monomial which is 0.\"\"\" return Monomial ( 0 , 0 ) @property def coefficient ( self ) : \"\"\"Return the coefficient of the monomial.\"\"\" return self . _coeff @coefficient . setter def coefficient ( self , coeff ) : \"\"\"Set the coefficient of the monomial.\"\"\" self . _coeff = coeff @property def degree ( self ) : \"\"\"Return the degree of the monomial.\"\"\" if self . _coeff == 0 : self . _degree = - inf elif self . _degree == - inf : self . _degree = 0 return self . _degree @degree . setter def degree ( self , degree ) : \"\"\"Set the degree of the monomial.\"\"\" self . _degree = degree @_extract_polynomial def __mul__ ( self , other ) : \"\"\"Return self * other. The class which is more permissive will be returned. \"\"\" if isinstance ( other , Monomial ) and self and other : return Monomial ( self . coefficient * other . coefficient , self . degree + other . degree ) return super (). __mul__ ( other ) @_extract_polynomial def __rmul__ ( self , other ) : \"\"\"Return other * self. The class which is more permissive will be returned. \"\"\" return self * other def __lt__ ( self , other ) : \"\"\"Return self < other. Compares the degrees of the monomials and then, if they are equal, compares their coefficients. \"\"\" if self . degree == other . degree : return self . a < other . a return self . degree < other . degree def __gt__ ( self , other ) : \"\"\"Return self > other. Compares the degrees of the monomials and then, if they are equal, compares their coefficients. \"\"\" if self . degree == other . degree : return self . a > other . a return self . degree > other . degree def __pow__ ( self , power , modulo = None ) : \"\"\"Return self ** power or pow(self, other, modulo).\"\"\" result = deepcopy ( self ) result **= power return result % modulo if modulo is not None else result def __ipow__ ( self , other ) : \"\"\"Return self **= power. Assumes self is mutable. Does not mutate in the case that self == 0 and other != 1. \"\"\" if not isinstance ( other , int ) : raise ValueError ( \"Can't call Monomial() **= x with a non-integer type.\" ) if other < 0 : raise ValueError ( \"Monomial can only be raised to a non-negative power.\" ) if not self : if other != 0 : return self terms = [ (1, 0) ] else : terms = [ (self.coefficient ** other, self.degree * other) ] # No native option exists to modify Monomial degree . return self . try_set_self ( terms ) def __lshift__ ( self , other ) : \"\"\"Return self << other. Returns a Monomial that is self * x^other. \"\"\" if other < 0 : return self >> - other if not self : return self . zero_instance () return Monomial ( self . coefficient , self . degree + other ) def __ilshift__ ( self , other ) : \"\"\"Return self <<= other. Returns a Monomial that is self * x^other. Does not guarantee the same type is returned. \"\"\" if other < 0 : self >>= - other return self if not self : return self return self . try_set_self ( [ (self.coefficient, self.degree + other) ] ) def __irshift__ ( self , other ) : \"\"\"Return self >>= other.\"\"\" if other < 0 : self <<= - other return self if not self : return self if other > self . degree : return self . try_set_self ( [ (0, 0) ] ) return self . try_set_self ( [ (self.coefficient, self.degree - other) ] ) def __repr__ ( self ) : \"\"\"Return repr(self).\"\"\" deg = max ( 0 , self . degree ) return \"Monomial({0!r}, {1!r})\" . format ( self . coefficient , deg ) def __getitem__ ( self , degree ) : \"\"\"Get the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : return self . _vector [ degree ] if degree == self . degree : return self . _coeff if degree > self . degree or degree < 0 : raise IndexError ( \"Attempt to get coefficient of term with \\ degree {0} of a {1}-degree monomial\" . format ( degree , self . degree )) return 0 def __setitem__ ( self , degree , new_value ) : \"\"\"Set the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : _vector = self . _vector _vector [ degree ] = new_value self . _vector = _vector elif degree == self . degree : self . coefficient = new_value else : raise TermError ( \"Can not set more than 1 term on Monomial.\" ) Ancestors (in MRO) polynomial.core.FixedTermPolynomial polynomial.core.Polynomial Descendants polynomial.core.Constant Class variables valid_term_counts Static methods zero_instance def zero_instance ( ) Return the Monomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Monomial which is 0.\"\"\" return Monomial ( 0 , 0 ) Instance variables coefficient Return the coefficient of the monomial. degree Return the degree of the monomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. Methods calculate def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms ) nth_derivative def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] ) terms_are_valid def terms_are_valid ( self , terms ) View Source def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) ) try_set_self def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True ) Polynomial class Polynomial ( * args , ** kwargs ) Implements a single-variable mathematical polynomial. View Source class Polynomial : \"\"\"Implements a single-variable mathematical polynomial.\"\"\" @ _ accepts_many_arguments def __ init__ ( self , iterable , from_monomials = False ) : \"\"\"Initialize the polynomial. iterable ::= the coefficients from the highest degree term to the lowest. The method is decorated so that it can accept many *args which it automatically transforms into a single iterable. If the from_monomials flag is True then it can accept many monomials or a single iterable with monomials which altogether add up to form this polynomial. Example usage: Polynomial([1,2,3,4,5]) Polynomial(1,2,3,4,5) Polynomial(range(1, 6)) Polynomial([(1,4), (2,3), (3,2), (4,1), (5,0)], from_monomials=True) Polynomial(((i + 1, 4 - i) for i in range(5)), from_monomials=True) \"\"\" if from_monomials: def monomial_to_tuple ( monomial ) : if isinstance ( monomial , Monomial ) : return monomial . a , monomial . degree if len ( monomial ) == 2 : return monomial raise TypeError ( \"{} cannot be a monomial.\" . format ( monomial )) self . terms = [ monomial_to_tuple ( monomial ) for monomial in iterable ] else : self . _ vector = _ trim ( list ( iterable )[ ::- 1 ]) @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial () def _ trim ( self ) : \"\"\"Trims self._vector to length. Keeps constant terms.\"\"\" self . _ vector = _ trim ( self . _ vector ) @property def degree ( self ) : \"\"\"Return the degree of the polynomial.\"\"\" if not self : return - inf # the degree of the zero polynomial is - infinity return len ( self . _ vector ) - 1 @property def derivative ( self ) : \"\"\"Return a polynomial object which is the derivative of self.\"\"\" return self . nth_derivative () def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c , x in zip ( self , reversed ( factors ))] ) @property def terms ( self ) : \"\"\"Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. \"\"\" s_d = self . degree return [( coeff , s_d - deg ) for deg , coeff in enumerate ( self ) if coeff ! = 0 ] @terms . setter def terms ( self , terms ) : \"\"\"Set the terms of self as a list of tuples in coeff, deg form.\"\"\" if not terms : _ vector = [ 0 ] else : list_len = max ( terms , key = lambda x : x [ 1 ])[ 1 ] + 1 _ vector = [ 0 ] * list_len for coeff , deg in terms : _ vector [ deg ] += coeff _ vector = _ trim ( _ vector ) self . _ vector = _ vector @property def monomials ( self ) : \"\"\"Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. \"\"\" return [ Monomial ( k , deg ) for k , deg in self . terms ] def calculate ( self , x ) : \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms ) def __ getattr__ ( self , name ) : \"\"\"Get coefficient by letter name: ax^n + bx^{n-1} + ... + yx + z.\"\"\" if len ( name ) ! = 1 : return object . __ getattribute__ ( self , name ) if name in string . ascii_letters: return self [ self . degree - ord ( name . lower ()) + ord ( 'a' )] raise AttributeError ( \"attribute {0} is not defined for Polynomial.\" . format ( name )) def __ setattr__ ( self , name , new_value ) : \"\"\"Set coefficient by letter name: ax^n + bx^{n-1} + ... + yx + z.\"\"\" if len ( name ) ! = 1 : object . __ setattr__ ( self , name , new_value ) elif name in string . ascii_letters: self [ self . degree - ord ( name . lower ()) + ord ( 'a' )] = new_value else : raise AttributeError ( \"attribute {0} is not defined for Polynomial.\" . format ( name )) def __ getitem__ ( self , degree ) : \"\"\"Get the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : return self . _ vector [ degree ] if degree == - inf and self . degree == - inf : return 0 if degree > self . degree or degree < 0 : raise IndexError ( \"Attempt to get coefficient of term with \\ degree {0} of a {1}-degree polynomial\" . format ( degree , self . degree )) return self . _ vector [ degree ] def __ setitem__ ( self , degree , new_value ) : \"\"\"Set the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : self . _ vector [ degree ] = new_value elif degree == - inf : if self . degree == - inf : self . _ vector = [ new_value ] else : raise IndexError ( \"Can not set term with degree -inf on a\" \" non-zero polynomial.\" ) elif degree > self . degree : raise IndexError ( \"Attempt to set coefficient of term with \\ degree {0} of a {1}-degree polynomial\" . format ( degree , self . degree )) else : self . _ vector [ degree ] = new_value self . _ trim () def __ iter__ ( self ) : \"\"\"Return the coefficients from the highest degree to the lowest.\"\"\" return reversed ( self . _ vector ) def __ repr__ ( self ) : \"\"\"Return repr(self).\"\"\" if not self : return \"Polynomial()\" terms = ', ' . join ([ repr ( ak ) for ak in self ]) return \"Polynomial({0})\" . format ( terms ) def __ str__ ( self ) : \"\"\"Return str(self).\"\"\" if not self : return \"0\" def components ( ak , k , is_leading ) : ak = str ( ak ) if ak [ 0 ] == \"-\" : # Strip - from ak ak = ak [ 1 : ] sign = \"-\" if is_leading else \"- \" else : sign = \"\" if is_leading else \"+ \" # if ak is 1 , the 1 is implicit when raising x to non - zero k , # so strip it . ak = \"\" if ak == \"1\" and k ! = 0 else ak # set x^k portion . if k == 0 : p , k = \"\" , \"\" elif k == 1 : p , k = \"x\" , \"\" else : p = \"x^\" return sign , ak , p , k # 0 : sign , 1 : coeff , 2 : x^ , 3 : a # eg . - 5 x^ 2 s_d = self . degree terms = [ \"{0}{1}{2}{3}\" . format ( * components ( ak , k , k == s_d )) for ak , k in self . terms ] return \" \" . join ( terms ) @ _ extract_polynomial def __ eq__ ( self , other ) : \"\"\"Return self == other. self == 0 <==> self == Polynomial() \"\"\" if other == 0 : return not self return self . degree == other . degree and self . terms == other . terms @ _ extract_polynomial def __ ne__ ( self , other ) : \"\"\"Return self != other. self != 0 <==> self != Polynomial() \"\"\" if other == 0 : return bool ( self ) return self . degree ! = other . degree or self . terms ! = other . terms def __ bool__ ( self ) : \"\"\"Return True if self is not a zero polynomial, otherwise False.\"\"\" self . _ trim () if not self . _ vector : return False if len ( self . _ vector ) > 1 : return True return self . _ vector [ 0 ] ! = 0 @ _ extract_polynomial def __ add__ ( self , other ) : \"\"\"Return self + other.\"\"\" if not self : return deepcopy ( other ) if not other : return deepcopy ( self ) return self . __ class__ (). try_set_self ( _ add ( self . terms , other . terms ) ) @ _ extract_polynomial def __ radd__ ( self , other ) : \"\"\"Return other + self.\"\"\" return self + other @ _ extract_polynomial def __ iadd__ ( self , other ) : \"\"\"Implement self += other.\"\"\" return self . try_set_self ( _ add ( self . terms , other . terms )) @ _ extract_polynomial def __ mul__ ( self , other ) : \"\"\"Return self * other.\"\"\" if not self or not other : return _ get_more_permissive_class ( self , other ). zero_instance () ret_val = deepcopy ( self ) ret_val *= other return ret_val @ _ extract_polynomial def __ rmul__ ( self , other ) : \"\"\"Return other * self.\"\"\" return self * other @ _ extract_polynomial def __ imul__ ( self , other ) : \"\"\"Implement self *= other.\"\"\" return self . try_set_self ( _ mul ( self . terms , other . terms )) def __ pos__ ( self ) : \"\"\"Return +self.\"\"\" self . _ trim () return deepcopy ( self ) def __ neg__ ( self ) : \"\"\"Return -self.\"\"\" ret_val = deepcopy ( self ) ret_val . _ vector = [ - x for x in _ trim ( self . _ vector )] return ret_val @ _ extract_polynomial def __ sub__ ( self , other ) : \"\"\"Return self - other.\"\"\" return self + ( - other ) @ _ extract_polynomial def __ rsub__ ( self , other ) : \"\"\"Return other - self.\"\"\" return other + ( - self ) @ _ extract_polynomial def __ isub__ ( self , other ) : \"\"\"Implement self -= other.\"\"\" return self . try_set_self ( _ sub ( self . terms , other . terms )) @ _ extract_polynomial def __ ifloordiv__ ( self , other ) : \"\"\"Return self //= other.\"\"\" return self . try_set_self ( divmod ( self , other )[ 0 ]. terms ) @ _ extract_polynomial def __ floordiv__ ( self , other ) : \"\"\"Return self // other.\"\"\" return divmod ( self , other )[ 0 ] @ _ extract_polynomial def __ imod__ ( self , other ) : \"\"\"Return self %= other.\"\"\" return self . try_set_self ( divmod ( self , other )[ 1 ]. terms ) @ _ extract_polynomial def __ mod__ ( self , other ) : \"\"\"Return self % other.\"\"\" return divmod ( self , other )[ 1 ] @ _ extract_polynomial def __ divmod__ ( self , other ) : \"\"\"Return divmod(self, other). The remainder is any term that would have degree < 0. \"\"\" if other . degree == - inf : raise ZeroDivisionError ( \"Can't divide a Polynomial by 0\" ) if isinstance ( other , Monomial ) : vec = self . _ vector [ other . degree :] remainder = self . _ vector [ :other . degree ] for i , v in enumerate ( vec ) : vec [ i ] = v / other . a return Polynomial ( vec [ ::- 1 ]), Polynomial ( remainder [ ::- 1 ]) working = self . terms wd0 = _ degree ( working ) other_terms = other . terms other_deg = other . degree vec = [] while wd0 >= other_deg: val = working [ 0 ][ 0 ] / other . a wd = wd0 working = _ sub ( working , _ mul ( other_terms , [( val , wd - other_deg )])) wd0 = _ degree ( working ) vec . append (( val , wd - other_deg if wd0 ! = - inf else 0 )) return ( Polynomial ( vec , from_monomials = True ), Polynomial ( working , from_monomials = True ) ) def __ pow__ ( self , power , modulo = None ) : \"\"\"Return self ** power or pow(self, other, modulo).\"\"\" if not isinstance ( power , int ) : raise ValueError ( \"Can't call Polynomial() ** x with a non-integer type.\" ) if power < 0 : raise ValueError ( \"Polynomial can only be raised to a non-negative power.\" ) if power == 0 : result = Constant ( 1 ) elif power % 2 == 1: result = Polynomial ( self ) if power > 1 : result *= ( self ** ( power // 2 )) ** 2 else : if power == 2 : result = Polynomial ( self ) else : result = self ** ( power // 2 ) result *= result return result % modulo if modulo is not None else result def __ ipow__ ( self , other ) : \"\"\"Return self **= power.\"\"\" terms = ( self ** other ). terms return self . try_set_self ( terms ) def __ lshift__ ( self , other ) : \"\"\"Return self << other. Increases the degree of each term by other. \"\"\" ret = deepcopy ( self ) ret <<= other return ret def __ ilshift__ ( self , other ) : \"\"\"Return self <<= other. Increases the degree of each term by other. \"\"\" if other < 0 : self >>= - other else : self . _ vector = [ 0 ] * other + self . _ vector return self def __ rshift__ ( self , other ) : \"\"\"Return self >> other. Decreases the degree of each term by other. \"\"\" ret = deepcopy ( self ) ret >>= other return ret def __ irshift__ ( self , other ) : \"\"\"Return self >>= other. Decreases the degree of each term by other. \"\"\" if other < 0 : self <<= - other else : self . _ vector = _ trim ( self . _ vector [ other :]) return self def __ contains__ ( self , item ) : \"\"\"Return item in self. Requires item to be a tuple, list of tuples, a set of tuples, or a Polynomial. Each tuple should contain two values, the first being the coefficient and the second being the degree. \"\"\" if isinstance ( item , tuple ) : return item in self . terms if isinstance ( item , list ) : return set ( item ). issubset ( self . terms ) if isinstance ( item , set ) : return item . issubset ( self . terms ) if isinstance ( item , Polynomial ) : return set ( item . terms ). issubset ( self . terms ) raise ValueError ( \"Can not check {0} for membership. A two-tuple, list of \" \"two-tuples, a set, or a Polynomial are required.\" . format ( type ( item ). __ name__ ) ) def terms_are_valid ( self , terms ) : \"\"\"Return true if the terms are valid.\"\"\" return True def try_set_self ( self , terms ) : \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ) : self . terms = terms return self return Polynomial ( terms , from_monomials = True ) Descendants polynomial.core.FixedDegreePolynomial polynomial.core.FixedTermPolynomial polynomial.frozen.FrozenPolynomial Static methods zero_instance def zero_instance ( ) Return the Polynomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial () Instance variables degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. Methods calculate def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms ) nth_derivative def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] ) terms_are_valid def terms_are_valid ( self , terms ) Return true if the terms are valid. View Source def terms_are_valid ( self , terms ): \"\"\"Return true if the terms are valid.\"\"\" return True try_set_self def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True ) PolynomialError class PolynomialError ( / , * args , ** kwargs ) Raised when a Polynomial encounters an error. View Source class PolynomialError ( Exception ): \"\"\"Raised when a Polynomial encounters an error.\"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Descendants polynomial.core.DegreeError polynomial.core.TermError Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. TermError class TermError ( / , * args , ** kwargs ) Raised when a Polynomial's term count changes. View Source class TermError ( PolynomialError ): \"\"\"Raised when a Polynomial's term count changes.\"\"\" Ancestors (in MRO) polynomial.core.PolynomialError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Core"},{"location":"reference/polynomial/core/#module-polynomialcore","text":"This module defines mutable polynomials, monomials and constants. View Source \"\"\"This module defines mutable polynomials, monomials and constants.\"\"\" from copy import deepcopy from itertools import chain from math import inf import string class PolynomialError ( Exception ) : \"\"\"Raised when a Polynomial encounters an error.\"\"\" class DegreeError ( PolynomialError ) : \"\"\"Raised when a Polynomial's degree changes.\"\"\" class TermError ( PolynomialError ) : \"\"\"Raised when a Polynomial's term count changes.\"\"\" def _ accepts_many_arguments ( function ) : \"\"\"Make a function that accepts an iterable handle many *args.\"\"\" def decorated ( self , * args , **kwargs ) : if len ( args ) == 1 and not isinstance ( args [ 0 ], ( int , float , complex )) : function ( self , args [ 0 ], kwargs ) else : function ( self , args , kwargs ) return decorated def _ extract_polynomial ( method ) : \"\"\"Call method with the second argument as a Polynomial. If casting is not possible or not appropriate, raise a ValueError. \"\"\" def decorated ( self , other ) : if isinstance ( other , Polynomial ) : return method ( self , other ) if isinstance ( other , ( int , float , complex )) : return method ( self , Constant ( other )) raise ValueError ( \"{0}.{1} requires a Polynomial or number, got {2}.\" . format ( self . __ class__ . __ name__ , method . __ name__ , type ( other ). __ name__ ) ) return decorated def _ get_more_permissive_class ( a , b ) : \"\"\"Return the most permissive class of a, b.\"\"\" a_cls = a . __ class__ b_cls = b . __ class__ return b_cls if issubclass ( a_cls , b_cls ) else a_cls def _ trim ( _ vector ) : \"\"\"Return _vector with all trailing zeros removed.\"\"\" if not _ vector or len ( _ vector ) == 1 : return _ vector ind = len ( _ vector ) while _ vector [ ind - 1 ] == 0 and ind > 0 : ind -= 1 return _ vector [ :ind ] def _ to_terms ( vec ) : \"\"\"Take a list of numbers and return the tuple form.\"\"\" s_d = _ degree ( vec , tuples = False ) return [( coeff , s_d - deg ) for deg , coeff in enumerate ( reversed ( vec )) if coeff ! = 0 ] def _ degree ( vec , tuples = True ) : \"\"\"Return the degree of vec.\"\"\" if not vec : return - inf if tuples : return max ( vec , key = lambda term : term [ 1 ] if term [ 0 ] else - inf )[ 1 ] return len ( vec ) - 1 def _ mul ( lhs , rhs ) : \"\"\"Return lhs * rhs.\"\"\" if not lhs or not rhs : return [( 0 , 0 )] deg = _ degree ( lhs ) + _ degree ( rhs ) + 1 res = [ 0 ] * deg for lcoeff , ldeg in lhs : for rcoeff , rdeg in rhs : res [ ldeg + rdeg ] += lcoeff * rcoeff return _ to_terms ( res ) def _ add ( lhs , rhs ) : \"\"\"Return lhs + rhs.\"\"\" if not lhs : return rhs if not rhs : return lhs deg = max ( _ degree ( lhs ), _ degree ( rhs )) + 1 res = [ 0 ] * deg for coeff , deg in chain ( lhs , rhs ) : res [ deg ] += coeff return _ to_terms ( res ) def _ neg ( vec ) : \"\"\"Return -vec.\"\"\" return [( - coeff , deg ) for coeff , deg in vec ] def _ sub ( lhs , rhs ) : \"\"\"Return lhs - rhs.\"\"\" if not lhs : return _ neg ( rhs ) if not rhs : return lhs deg = max ( _ degree ( lhs ), _ degree ( rhs )) + 1 res = [ 0 ] * deg for coeff , deg in lhs : res [ deg ] += coeff for coeff , deg in rhs : res [ deg ] -= coeff return _ to_terms ( res ) class Polynomial : \"\"\"Implements a single-variable mathematical polynomial.\"\"\" @ _ accepts_many_arguments def __ init__ ( self , iterable , from_monomials = False ) : \"\"\"Initialize the polynomial. iterable ::= the coefficients from the highest degree term to the lowest. The method is decorated so that it can accept many *args which it automatically transforms into a single iterable. If the from_monomials flag is True then it can accept many monomials or a single iterable with monomials which altogether add up to form this polynomial. Example usage: Polynomial([1,2,3,4,5]) Polynomial(1,2,3,4,5) Polynomial(range(1, 6)) Polynomial([(1,4), (2,3), (3,2), (4,1), (5,0)], from_monomials=True) Polynomial(((i + 1, 4 - i) for i in range(5)), from_monomials=True) \"\"\" if from_monomials: def monomial_to_tuple ( monomial ) : if isinstance ( monomial , Monomial ) : return monomial . a , monomial . degree if len ( monomial ) == 2 : return monomial raise TypeError ( \"{} cannot be a monomial.\" . format ( monomial )) self . terms = [ monomial_to_tuple ( monomial ) for monomial in iterable ] else : self . _ vector = _ trim ( list ( iterable )[ ::- 1 ]) @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial () def _ trim ( self ) : \"\"\"Trims self._vector to length. Keeps constant terms.\"\"\" self . _ vector = _ trim ( self . _ vector ) @property def degree ( self ) : \"\"\"Return the degree of the polynomial.\"\"\" if not self : return - inf # the degree of the zero polynomial is - infinity return len ( self . _ vector ) - 1 @property def derivative ( self ) : \"\"\"Return a polynomial object which is the derivative of self.\"\"\" return self . nth_derivative () def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c , x in zip ( self , reversed ( factors ))] ) @property def terms ( self ) : \"\"\"Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. \"\"\" s_d = self . degree return [( coeff , s_d - deg ) for deg , coeff in enumerate ( self ) if coeff ! = 0 ] @terms . setter def terms ( self , terms ) : \"\"\"Set the terms of self as a list of tuples in coeff, deg form.\"\"\" if not terms : _ vector = [ 0 ] else : list_len = max ( terms , key = lambda x : x [ 1 ])[ 1 ] + 1 _ vector = [ 0 ] * list_len for coeff , deg in terms : _ vector [ deg ] += coeff _ vector = _ trim ( _ vector ) self . _ vector = _ vector @property def monomials ( self ) : \"\"\"Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. \"\"\" return [ Monomial ( k , deg ) for k , deg in self . terms ] def calculate ( self , x ) : \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms ) def __ getattr__ ( self , name ) : \"\"\"Get coefficient by letter name: ax^n + bx^{n-1} + ... + yx + z.\"\"\" if len ( name ) ! = 1 : return object . __ getattribute__ ( self , name ) if name in string . ascii_letters: return self [ self . degree - ord ( name . lower ()) + ord ( 'a' )] raise AttributeError ( \"attribute {0} is not defined for Polynomial.\" . format ( name )) def __ setattr__ ( self , name , new_value ) : \"\"\"Set coefficient by letter name: ax^n + bx^{n-1} + ... + yx + z.\"\"\" if len ( name ) ! = 1 : object . __ setattr__ ( self , name , new_value ) elif name in string . ascii_letters: self [ self . degree - ord ( name . lower ()) + ord ( 'a' )] = new_value else : raise AttributeError ( \"attribute {0} is not defined for Polynomial.\" . format ( name )) def __ getitem__ ( self , degree ) : \"\"\"Get the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : return self . _ vector [ degree ] if degree == - inf and self . degree == - inf : return 0 if degree > self . degree or degree < 0 : raise IndexError ( \"Attempt to get coefficient of term with \\ degree {0} of a {1}-degree polynomial\" . format ( degree , self . degree )) return self . _ vector [ degree ] def __ setitem__ ( self , degree , new_value ) : \"\"\"Set the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : self . _ vector [ degree ] = new_value elif degree == - inf : if self . degree == - inf : self . _ vector = [ new_value ] else : raise IndexError ( \"Can not set term with degree -inf on a\" \" non-zero polynomial.\" ) elif degree > self . degree : raise IndexError ( \"Attempt to set coefficient of term with \\ degree {0} of a {1}-degree polynomial\" . format ( degree , self . degree )) else : self . _ vector [ degree ] = new_value self . _ trim () def __ iter__ ( self ) : \"\"\"Return the coefficients from the highest degree to the lowest.\"\"\" return reversed ( self . _ vector ) def __ repr__ ( self ) : \"\"\"Return repr(self).\"\"\" if not self : return \"Polynomial()\" terms = ', ' . join ([ repr ( ak ) for ak in self ]) return \"Polynomial({0})\" . format ( terms ) def __ str__ ( self ) : \"\"\"Return str(self).\"\"\" if not self : return \"0\" def components ( ak , k , is_leading ) : ak = str ( ak ) if ak [ 0 ] == \"-\" : # Strip - from ak ak = ak [ 1 : ] sign = \"-\" if is_leading else \"- \" else : sign = \"\" if is_leading else \"+ \" # if ak is 1 , the 1 is implicit when raising x to non - zero k , # so strip it . ak = \"\" if ak == \"1\" and k ! = 0 else ak # set x^k portion . if k == 0 : p , k = \"\" , \"\" elif k == 1 : p , k = \"x\" , \"\" else : p = \"x^\" return sign , ak , p , k # 0 : sign , 1 : coeff , 2 : x^ , 3 : a # eg . - 5 x^ 2 s_d = self . degree terms = [ \"{0}{1}{2}{3}\" . format ( * components ( ak , k , k == s_d )) for ak , k in self . terms ] return \" \" . join ( terms ) @ _ extract_polynomial def __ eq__ ( self , other ) : \"\"\"Return self == other. self == 0 <==> self == Polynomial() \"\"\" if other == 0 : return not self return self . degree == other . degree and self . terms == other . terms @ _ extract_polynomial def __ ne__ ( self , other ) : \"\"\"Return self != other. self != 0 <==> self != Polynomial() \"\"\" if other == 0 : return bool ( self ) return self . degree ! = other . degree or self . terms ! = other . terms def __ bool__ ( self ) : \"\"\"Return True if self is not a zero polynomial, otherwise False.\"\"\" self . _ trim () if not self . _ vector : return False if len ( self . _ vector ) > 1 : return True return self . _ vector [ 0 ] ! = 0 @ _ extract_polynomial def __ add__ ( self , other ) : \"\"\"Return self + other.\"\"\" if not self : return deepcopy ( other ) if not other : return deepcopy ( self ) return self . __ class__ (). try_set_self ( _ add ( self . terms , other . terms ) ) @ _ extract_polynomial def __ radd__ ( self , other ) : \"\"\"Return other + self.\"\"\" return self + other @ _ extract_polynomial def __ iadd__ ( self , other ) : \"\"\"Implement self += other.\"\"\" return self . try_set_self ( _ add ( self . terms , other . terms )) @ _ extract_polynomial def __ mul__ ( self , other ) : \"\"\"Return self * other.\"\"\" if not self or not other : return _ get_more_permissive_class ( self , other ). zero_instance () ret_val = deepcopy ( self ) ret_val *= other return ret_val @ _ extract_polynomial def __ rmul__ ( self , other ) : \"\"\"Return other * self.\"\"\" return self * other @ _ extract_polynomial def __ imul__ ( self , other ) : \"\"\"Implement self *= other.\"\"\" return self . try_set_self ( _ mul ( self . terms , other . terms )) def __ pos__ ( self ) : \"\"\"Return +self.\"\"\" self . _ trim () return deepcopy ( self ) def __ neg__ ( self ) : \"\"\"Return -self.\"\"\" ret_val = deepcopy ( self ) ret_val . _ vector = [ - x for x in _ trim ( self . _ vector )] return ret_val @ _ extract_polynomial def __ sub__ ( self , other ) : \"\"\"Return self - other.\"\"\" return self + ( - other ) @ _ extract_polynomial def __ rsub__ ( self , other ) : \"\"\"Return other - self.\"\"\" return other + ( - self ) @ _ extract_polynomial def __ isub__ ( self , other ) : \"\"\"Implement self -= other.\"\"\" return self . try_set_self ( _ sub ( self . terms , other . terms )) @ _ extract_polynomial def __ ifloordiv__ ( self , other ) : \"\"\"Return self //= other.\"\"\" return self . try_set_self ( divmod ( self , other )[ 0 ]. terms ) @ _ extract_polynomial def __ floordiv__ ( self , other ) : \"\"\"Return self // other.\"\"\" return divmod ( self , other )[ 0 ] @ _ extract_polynomial def __ imod__ ( self , other ) : \"\"\"Return self %= other.\"\"\" return self . try_set_self ( divmod ( self , other )[ 1 ]. terms ) @ _ extract_polynomial def __ mod__ ( self , other ) : \"\"\"Return self % other.\"\"\" return divmod ( self , other )[ 1 ] @ _ extract_polynomial def __ divmod__ ( self , other ) : \"\"\"Return divmod(self, other). The remainder is any term that would have degree < 0. \"\"\" if other . degree == - inf : raise ZeroDivisionError ( \"Can't divide a Polynomial by 0\" ) if isinstance ( other , Monomial ) : vec = self . _ vector [ other . degree :] remainder = self . _ vector [ :other . degree ] for i , v in enumerate ( vec ) : vec [ i ] = v / other . a return Polynomial ( vec [ ::- 1 ]), Polynomial ( remainder [ ::- 1 ]) working = self . terms wd0 = _ degree ( working ) other_terms = other . terms other_deg = other . degree vec = [] while wd0 >= other_deg: val = working [ 0 ][ 0 ] / other . a wd = wd0 working = _ sub ( working , _ mul ( other_terms , [( val , wd - other_deg )])) wd0 = _ degree ( working ) vec . append (( val , wd - other_deg if wd0 ! = - inf else 0 )) return ( Polynomial ( vec , from_monomials = True ), Polynomial ( working , from_monomials = True ) ) def __ pow__ ( self , power , modulo = None ) : \"\"\"Return self ** power or pow(self, other, modulo).\"\"\" if not isinstance ( power , int ) : raise ValueError ( \"Can't call Polynomial() ** x with a non-integer type.\" ) if power < 0 : raise ValueError ( \"Polynomial can only be raised to a non-negative power.\" ) if power == 0 : result = Constant ( 1 ) elif power % 2 == 1: result = Polynomial ( self ) if power > 1 : result *= ( self ** ( power // 2 )) ** 2 else : if power == 2 : result = Polynomial ( self ) else : result = self ** ( power // 2 ) result *= result return result % modulo if modulo is not None else result def __ ipow__ ( self , other ) : \"\"\"Return self **= power.\"\"\" terms = ( self ** other ). terms return self . try_set_self ( terms ) def __ lshift__ ( self , other ) : \"\"\"Return self << other. Increases the degree of each term by other. \"\"\" ret = deepcopy ( self ) ret <<= other return ret def __ ilshift__ ( self , other ) : \"\"\"Return self <<= other. Increases the degree of each term by other. \"\"\" if other < 0 : self >>= - other else : self . _ vector = [ 0 ] * other + self . _ vector return self def __ rshift__ ( self , other ) : \"\"\"Return self >> other. Decreases the degree of each term by other. \"\"\" ret = deepcopy ( self ) ret >>= other return ret def __ irshift__ ( self , other ) : \"\"\"Return self >>= other. Decreases the degree of each term by other. \"\"\" if other < 0 : self <<= - other else : self . _ vector = _ trim ( self . _ vector [ other :]) return self def __ contains__ ( self , item ) : \"\"\"Return item in self. Requires item to be a tuple, list of tuples, a set of tuples, or a Polynomial. Each tuple should contain two values, the first being the coefficient and the second being the degree. \"\"\" if isinstance ( item , tuple ) : return item in self . terms if isinstance ( item , list ) : return set ( item ). issubset ( self . terms ) if isinstance ( item , set ) : return item . issubset ( self . terms ) if isinstance ( item , Polynomial ) : return set ( item . terms ). issubset ( self . terms ) raise ValueError ( \"Can not check {0} for membership. A two-tuple, list of \" \"two-tuples, a set, or a Polynomial are required.\" . format ( type ( item ). __ name__ ) ) def terms_are_valid ( self , terms ) : \"\"\"Return true if the terms are valid.\"\"\" return True def try_set_self ( self , terms ) : \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ) : self . terms = terms return self return Polynomial ( terms , from_monomials = True ) def _ setvalue_decorator ( error , _ terms_are_valid , _ fn ) : \"\"\"Decorate __setattr__, checking if self._vector is still valid.\"\"\" def method ( self , name , new_value ) : _ fn ( self , name , new_value ) if ( name == '_vector' and not _ terms_are_valid ( self , _ to_terms ( self . _ vector ))) : raise error return method class FixedDegreePolynomial ( Polynomial ) : \"\"\"This Polynomial must maintain its degree.\"\"\" def __ init_subclass__ ( cls , **kwargs ) : \"\"\"Init a subclass of self.\"\"\" deg = kwargs [ \"valid_degrees\" ] if not isinstance ( deg , tuple ) : deg = ( deg ,) cls . valid_degrees = deg orig_terms_are_valid = cls . terms_are_valid def _ terms_are_valid ( self , terms ) : return _ degree ( terms ) in self . valid_degrees def terms_are_valid ( self , terms ) : return ( _ terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) ) cls . terms_are_valid = terms_are_valid cls . __ setattr__ = _ setvalue_decorator ( DegreeError , _ terms_are_valid , cls . __ setattr__ ) class FixedTermPolynomial ( Polynomial ) : \"\"\"This Polynomial must maintain the number of terms.\"\"\" def __ init_subclass__ ( cls , **kwargs ) : \"\"\"Init a subclass of self. Expects valid_term_counts to be provided as a tuple. \"\"\" cls . valid_term_counts = kwargs [ \"valid_term_counts\" ] orig_terms_are_valid = cls . terms_are_valid # Check that number of terms is correct . def _ terms_are_valid ( self , terms ) : return len ( terms ) in self . valid_term_counts def terms_are_valid ( self , terms ) : return ( _ terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) ) cls . terms_are_valid = terms_are_valid cls . __ setattr__ = _ setvalue_decorator ( TermError , _ terms_are_valid , cls . __ setattr__ ) class Monomial ( FixedTermPolynomial , valid_term_counts= ( 0 , 1 )) : \"\"\"Implements a single-variable monomial. A single-term polynomial.\"\"\" def __ init__ ( self , coefficient = 1 , degree = 1 ) : \"\"\"Initialize the following monomial: coefficient * x^(degree).\"\"\" if not isinstance ( degree , int ) : raise ValueError ( \"Monomial's degree should be a natural number.\" ) if degree < 0 : raise ValueError ( \"Polynomials cannot have negative-degree terms.\" ) self . _ degree = degree self . _ coeff = coefficient def _ trim ( self ) : \"\"\"Trims self._vector to length. Keeps constant terms.\"\"\" @property def terms ( self ) : \"\"\"Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. \"\"\" if self . _ coeff == 0 : return [( 0 , 0 )] return [( self . _ coeff , self . _ degree )] @terms . setter def terms ( self , terms ) : \"\"\"Set the terms of self as a list of tuples in coeff, deg form.\"\"\" if not terms : self . _ coeff = 0 elif len ( terms ) == 1 : self . _ coeff , self . _ degree = terms [ 0 ] else : terms = sorted ([ term for term in terms if term [ 0 ] ! = 0 ], key = lambda x : x [ 1 ]) if terms [ 0 ][ 1 ] == terms [ - 1 ][ 1 ] : self . _ coeff = sum ( term [ 0 ] for term in terms ) self . _ degree = terms [ 0 ][ 1 ] else : err_msg = \"terms has more than one non-zero term.\" curr_coeff , curr_deg = terms [ 0 ] termx = [] for coeff , deg in terms [ 1 : ] : if curr_deg == deg : curr_coeff += coeff else : if curr_coeff ! = 0 : if termx : raise TermError ( err_msg ) termx . append (( curr_coeff , curr_deg )) curr_coeff = coeff curr_deg = deg if termx : if curr_coeff: raise TermError ( err_msg ) self . _ coeff , self . _ degree = termx [ 0 ] else : self . _ coeff = curr_coeff self . _ degree = curr_deg @property def _ vector ( self ) : \"\"\"Get _vector.\"\"\" if self . degree == - inf : return [ 0 ] return [ 0 ] * self . _ degree + [ self . _ coeff ] @ _ vector . setter def _ vector ( self , _ vector ) : \"\"\"Set _vector.\"\"\" max_deg = len ( _ vector ) - 1 is_set = False for index , coeff in enumerate ( reversed ( _ vector )) : if coeff ! = 0 : if is_set: raise TermError ( \"_vector has > 1 non-zero term.\" ) self . _ coeff = coeff self . _ degree = max_deg - index is_set = True if not is_set: self . _ coeff = 0 @classmethod def zero_instance ( cls ) : \"\"\"Return the Monomial which is 0.\"\"\" return Monomial ( 0 , 0 ) @property def coefficient ( self ) : \"\"\"Return the coefficient of the monomial.\"\"\" return self . _ coeff @coefficient . setter def coefficient ( self , coeff ) : \"\"\"Set the coefficient of the monomial.\"\"\" self . _ coeff = coeff @property def degree ( self ) : \"\"\"Return the degree of the monomial.\"\"\" if self . _ coeff == 0 : self . _ degree = - inf elif self . _ degree == - inf : self . _ degree = 0 return self . _ degree @degree . setter def degree ( self , degree ) : \"\"\"Set the degree of the monomial.\"\"\" self . _ degree = degree @ _ extract_polynomial def __ mul__ ( self , other ) : \"\"\"Return self * other. The class which is more permissive will be returned. \"\"\" if isinstance ( other , Monomial ) and self and other : return Monomial ( self . coefficient * other . coefficient , self . degree + other . degree ) return super (). __ mul__ ( other ) @ _ extract_polynomial def __ rmul__ ( self , other ) : \"\"\"Return other * self. The class which is more permissive will be returned. \"\"\" return self * other def __ lt__ ( self , other ) : \"\"\"Return self < other. Compares the degrees of the monomials and then, if they are equal, compares their coefficients. \"\"\" if self . degree == other . degree : return self . a < other . a return self . degree < other . degree def __ gt__ ( self , other ) : \"\"\"Return self > other. Compares the degrees of the monomials and then, if they are equal, compares their coefficients. \"\"\" if self . degree == other . degree : return self . a > other . a return self . degree > other . degree def __ pow__ ( self , power , modulo = None ) : \"\"\"Return self ** power or pow(self, other, modulo).\"\"\" result = deepcopy ( self ) result **= power return result % modulo if modulo is not None else result def __ ipow__ ( self , other ) : \"\"\"Return self **= power. Assumes self is mutable. Does not mutate in the case that self == 0 and other != 1. \"\"\" if not isinstance ( other , int ) : raise ValueError ( \"Can't call Monomial() **= x with a non-integer type.\" ) if other < 0 : raise ValueError ( \"Monomial can only be raised to a non-negative power.\" ) if not self : if other ! = 0 : return self terms = [( 1 , 0 )] else : terms = [( self . coefficient ** other , self . degree * other )] # No native option exists to modify Monomial degree . return self . try_set_self ( terms ) def __ lshift__ ( self , other ) : \"\"\"Return self << other. Returns a Monomial that is self * x^other. \"\"\" if other < 0 : return self >> - other if not self : return self . zero_instance () return Monomial ( self . coefficient , self . degree + other ) def __ ilshift__ ( self , other ) : \"\"\"Return self <<= other. Returns a Monomial that is self * x^other. Does not guarantee the same type is returned. \"\"\" if other < 0 : self >>= - other return self if not self : return self return self . try_set_self ([( self . coefficient , self . degree + other )]) def __ irshift__ ( self , other ) : \"\"\"Return self >>= other.\"\"\" if other < 0 : self <<= - other return self if not self : return self if other > self . degree : return self . try_set_self ([( 0 , 0 )]) return self . try_set_self ([( self . coefficient , self . degree - other )]) def __ repr__ ( self ) : \"\"\"Return repr(self).\"\"\" deg = max ( 0 , self . degree ) return \"Monomial({0!r}, {1!r})\" . format ( self . coefficient , deg ) def __ getitem__ ( self , degree ) : \"\"\"Get the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : return self . _ vector [ degree ] if degree == self . degree : return self . _ coeff if degree > self . degree or degree < 0 : raise IndexError ( \"Attempt to get coefficient of term with \\ degree {0} of a {1}-degree monomial\" . format ( degree , self . degree )) return 0 def __ setitem__ ( self , degree , new_value ) : \"\"\"Set the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : _ vector = self . _ vector _ vector [ degree ] = new_value self . _ vector = _ vector elif degree == self . degree : self . coefficient = new_value else : raise TermError ( \"Can not set more than 1 term on Monomial.\" ) class Constant ( FixedDegreePolynomial , Monomial , valid_degrees= ( 0 , - inf )) : \"\"\"Implements constants as monomials of degree 0.\"\"\" def __ init__ ( self , const = 1 ) : \"\"\"Initialize the constant with value const.\"\"\" Monomial . __ init__ ( self , const , 0 ) @classmethod def zero_instance ( cls ) : \"\"\"Return the constant which is 0.\"\"\" return Constant ( 0 ) def __ eq__ ( self , other ) : \"\"\"Return self == other.\"\"\" if other == self . const : return True return super (). __ eq__ ( other ) @property def degree ( self ) : \"\"\"Return self.degree.\"\"\" return 0 if self . _ coeff else - inf @degree . setter def degree ( self , degree ) : \"\"\"Set self.degree.\"\"\" raise DegreeError ( \"Can't change the degree of Constant\" ) @property def const ( self ) : \"\"\"Return the constant term.\"\"\" return self . coefficient @const . setter def const ( self , val ) : \"\"\"Set the constant term.\"\"\" self . coefficient = val @ _ extract_polynomial def __ mul__ ( self , other ) : \"\"\"Return self * other.\"\"\" if isinstance ( other , Constant ) : return Constant ( self . const * other . const ) return super (). __ mul__ ( other ) def __ int__ ( self ) : \"\"\"Return int(self).\"\"\" return int ( self . const ) def __ float__ ( self ) : \"\"\"Return float(self).\"\"\" return float ( self . const ) def __ complex__ ( self ) : \"\"\"Return complex(self).\"\"\" return complex ( self . const ) def __ repr__ ( self ) : \"\"\"Return repr(self).\"\"\" return \"Constant({0!r})\" . format ( self . const )","title":"Module polynomial.core"},{"location":"reference/polynomial/core/#variables","text":"inf","title":"Variables"},{"location":"reference/polynomial/core/#classes","text":"","title":"Classes"},{"location":"reference/polynomial/core/#constant","text":"class Constant ( const = 1 ) Implements constants as monomials of degree 0. View Source class Constant ( FixedDegreePolynomial , Monomial , valid_degrees = ( 0 , - inf )): \"\"\"Implements constants as monomials of degree 0.\"\"\" def __init__ ( self , const = 1 ): \"\"\"Initialize the constant with value const.\"\"\" Monomial . __init__ ( self , const , 0 ) @ classmethod def zero_instance ( cls ): \"\"\"Return the constant which is 0.\"\"\" return Constant ( 0 ) def __eq__ ( self , other ): \"\"\"Return self == other.\"\"\" if other == self . const : return True return super () . __eq__ ( other ) @ property def degree ( self ): \"\"\"Return self.degree.\"\"\" return 0 if self . _coeff else - inf @ degree . setter def degree ( self , degree ): \"\"\"Set self.degree.\"\"\" raise DegreeError ( \"Can't change the degree of Constant\" ) @ property def const ( self ): \"\"\"Return the constant term.\"\"\" return self . coefficient @ const . setter def const ( self , val ): \"\"\"Set the constant term.\"\"\" self . coefficient = val @ _extract_polynomial def __mul__ ( self , other ): \"\"\"Return self * other.\"\"\" if isinstance ( other , Constant ): return Constant ( self . const * other . const ) return super () . __mul__ ( other ) def __int__ ( self ): \"\"\"Return int(self).\"\"\" return int ( self . const ) def __float__ ( self ): \"\"\"Return float(self).\"\"\" return float ( self . const ) def __complex__ ( self ): \"\"\"Return complex(self).\"\"\" return complex ( self . const ) def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" return \"Constant({0!r})\" . format ( self . const )","title":"Constant"},{"location":"reference/polynomial/core/#ancestors-in-mro","text":"polynomial.core.FixedDegreePolynomial polynomial.core.Monomial polynomial.core.FixedTermPolynomial polynomial.core.Polynomial","title":"Ancestors (in MRO)"},{"location":"reference/polynomial/core/#descendants","text":"polynomial.frozen.ZeroPolynomial","title":"Descendants"},{"location":"reference/polynomial/core/#class-variables","text":"valid_degrees valid_term_counts","title":"Class variables"},{"location":"reference/polynomial/core/#static-methods","text":"","title":"Static methods"},{"location":"reference/polynomial/core/#zero_instance","text":"def zero_instance ( ) Return the constant which is 0. View Source @ classmethod def zero_instance ( cls ): \"\"\"Return the constant which is 0.\"\"\" return Constant ( 0 )","title":"zero_instance"},{"location":"reference/polynomial/core/#instance-variables","text":"coefficient Return the coefficient of the monomial. const Return the constant term. degree Return self.degree. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient.","title":"Instance variables"},{"location":"reference/polynomial/core/#methods","text":"","title":"Methods"},{"location":"reference/polynomial/core/#calculate","text":"def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms )","title":"calculate"},{"location":"reference/polynomial/core/#nth_derivative","text":"def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] )","title":"nth_derivative"},{"location":"reference/polynomial/core/#terms_are_valid","text":"def terms_are_valid ( self , terms ) View Source def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) )","title":"terms_are_valid"},{"location":"reference/polynomial/core/#try_set_self","text":"def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True )","title":"try_set_self"},{"location":"reference/polynomial/core/#degreeerror","text":"class DegreeError ( / , * args , ** kwargs ) Raised when a Polynomial's degree changes. View Source class DegreeError ( PolynomialError ): \"\"\"Raised when a Polynomial's degree changes.\"\"\"","title":"DegreeError"},{"location":"reference/polynomial/core/#ancestors-in-mro_1","text":"polynomial.core.PolynomialError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/polynomial/core/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/polynomial/core/#methods_1","text":"","title":"Methods"},{"location":"reference/polynomial/core/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/polynomial/core/#fixeddegreepolynomial","text":"class FixedDegreePolynomial ( * args , ** kwargs ) This Polynomial must maintain its degree. View Source class FixedDegreePolynomial ( Polynomial ): \"\"\"This Polynomial must maintain its degree.\"\"\" def __init_subclass__ ( cls , ** kwargs ): \"\"\"Init a subclass of self.\"\"\" deg = kwargs [ \"valid_degrees\" ] if not isinstance ( deg , tuple ): deg = ( deg ,) cls . valid_degrees = deg orig_terms_are_valid = cls . terms_are_valid def _terms_are_valid ( self , terms ): return _degree ( terms ) in self . valid_degrees def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) ) cls . terms_are_valid = terms_are_valid cls . __setattr__ = _setvalue_decorator ( DegreeError , _terms_are_valid , cls . __setattr__ )","title":"FixedDegreePolynomial"},{"location":"reference/polynomial/core/#ancestors-in-mro_2","text":"polynomial.core.Polynomial","title":"Ancestors (in MRO)"},{"location":"reference/polynomial/core/#descendants_1","text":"polynomial.core.Constant polynomial.binomial.LinearBinomial polynomial.trinomial.QuadraticTrinomial","title":"Descendants"},{"location":"reference/polynomial/core/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/polynomial/core/#zero_instance_1","text":"def zero_instance ( ) Return the Polynomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial ()","title":"zero_instance"},{"location":"reference/polynomial/core/#instance-variables_1","text":"degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient.","title":"Instance variables"},{"location":"reference/polynomial/core/#methods_2","text":"","title":"Methods"},{"location":"reference/polynomial/core/#calculate_1","text":"def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms )","title":"calculate"},{"location":"reference/polynomial/core/#nth_derivative_1","text":"def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] )","title":"nth_derivative"},{"location":"reference/polynomial/core/#terms_are_valid_1","text":"def terms_are_valid ( self , terms ) Return true if the terms are valid. View Source def terms_are_valid ( self , terms ): \"\"\"Return true if the terms are valid.\"\"\" return True","title":"terms_are_valid"},{"location":"reference/polynomial/core/#try_set_self_1","text":"def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True )","title":"try_set_self"},{"location":"reference/polynomial/core/#fixedtermpolynomial","text":"class FixedTermPolynomial ( * args , ** kwargs ) This Polynomial must maintain the number of terms. View Source class FixedTermPolynomial ( Polynomial ): \"\"\"This Polynomial must maintain the number of terms.\"\"\" def __init_subclass__ ( cls , ** kwargs ): \"\"\"Init a subclass of self. Expects valid_term_counts to be provided as a tuple. \"\"\" cls . valid_term_counts = kwargs [ \"valid_term_counts\" ] orig_terms_are_valid = cls . terms_are_valid # Check that number of terms is correct. def _terms_are_valid ( self , terms ): return len ( terms ) in self . valid_term_counts def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) ) cls . terms_are_valid = terms_are_valid cls . __setattr__ = _setvalue_decorator ( TermError , _terms_are_valid , cls . __setattr__ )","title":"FixedTermPolynomial"},{"location":"reference/polynomial/core/#ancestors-in-mro_3","text":"polynomial.core.Polynomial","title":"Ancestors (in MRO)"},{"location":"reference/polynomial/core/#descendants_2","text":"polynomial.core.Monomial polynomial.binomial.Binomial polynomial.trinomial.Trinomial","title":"Descendants"},{"location":"reference/polynomial/core/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/polynomial/core/#zero_instance_2","text":"def zero_instance ( ) Return the Polynomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial ()","title":"zero_instance"},{"location":"reference/polynomial/core/#instance-variables_2","text":"degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient.","title":"Instance variables"},{"location":"reference/polynomial/core/#methods_3","text":"","title":"Methods"},{"location":"reference/polynomial/core/#calculate_2","text":"def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms )","title":"calculate"},{"location":"reference/polynomial/core/#nth_derivative_2","text":"def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] )","title":"nth_derivative"},{"location":"reference/polynomial/core/#terms_are_valid_2","text":"def terms_are_valid ( self , terms ) Return true if the terms are valid. View Source def terms_are_valid ( self , terms ): \"\"\"Return true if the terms are valid.\"\"\" return True","title":"terms_are_valid"},{"location":"reference/polynomial/core/#try_set_self_2","text":"def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True )","title":"try_set_self"},{"location":"reference/polynomial/core/#monomial","text":"class Monomial ( coefficient = 1 , degree = 1 ) Implements a single-variable monomial. A single-term polynomial. View Source class Monomial ( FixedTermPolynomial , valid_term_counts = ( 0 , 1 )) : \"\"\"Implements a single-variable monomial. A single-term polynomial.\"\"\" def __init__ ( self , coefficient = 1 , degree = 1 ) : \"\"\"Initialize the following monomial: coefficient * x^(degree).\"\"\" if not isinstance ( degree , int ) : raise ValueError ( \"Monomial's degree should be a natural number.\" ) if degree < 0 : raise ValueError ( \"Polynomials cannot have negative-degree terms.\" ) self . _degree = degree self . _coeff = coefficient def _trim ( self ) : \"\"\"Trims self._vector to length. Keeps constant terms.\"\"\" @property def terms ( self ) : \"\"\"Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. \"\"\" if self . _coeff == 0 : return [ (0, 0) ] return [ (self._coeff, self._degree) ] @terms . setter def terms ( self , terms ) : \"\"\"Set the terms of self as a list of tuples in coeff, deg form.\"\"\" if not terms : self . _coeff = 0 elif len ( terms ) == 1 : self . _coeff , self . _degree = terms [ 0 ] else : terms = sorted ( [ term for term in terms if term[0 ] != 0 ] , key = lambda x : x [ 1 ] ) if terms [ 0 ][ 1 ] == terms [ -1 ][ 1 ] : self . _coeff = sum ( term [ 0 ] for term in terms ) self . _degree = terms [ 0 ][ 1 ] else : err_msg = \"terms has more than one non-zero term.\" curr_coeff , curr_deg = terms [ 0 ] termx = [] for coeff , deg in terms [ 1: ] : if curr_deg == deg : curr_coeff += coeff else : if curr_coeff != 0 : if termx : raise TermError ( err_msg ) termx . append (( curr_coeff , curr_deg )) curr_coeff = coeff curr_deg = deg if termx : if curr_coeff : raise TermError ( err_msg ) self . _coeff , self . _degree = termx [ 0 ] else : self . _coeff = curr_coeff self . _degree = curr_deg @property def _vector ( self ) : \"\"\"Get _vector.\"\"\" if self . degree == - inf : return [ 0 ] return [ 0 ] * self . _degree + [ self._coeff ] @_vector . setter def _vector ( self , _vector ) : \"\"\"Set _vector.\"\"\" max_deg = len ( _vector ) - 1 is_set = False for index , coeff in enumerate ( reversed ( _vector )) : if coeff != 0 : if is_set : raise TermError ( \"_vector has > 1 non-zero term.\" ) self . _coeff = coeff self . _degree = max_deg - index is_set = True if not is_set : self . _coeff = 0 @classmethod def zero_instance ( cls ) : \"\"\"Return the Monomial which is 0.\"\"\" return Monomial ( 0 , 0 ) @property def coefficient ( self ) : \"\"\"Return the coefficient of the monomial.\"\"\" return self . _coeff @coefficient . setter def coefficient ( self , coeff ) : \"\"\"Set the coefficient of the monomial.\"\"\" self . _coeff = coeff @property def degree ( self ) : \"\"\"Return the degree of the monomial.\"\"\" if self . _coeff == 0 : self . _degree = - inf elif self . _degree == - inf : self . _degree = 0 return self . _degree @degree . setter def degree ( self , degree ) : \"\"\"Set the degree of the monomial.\"\"\" self . _degree = degree @_extract_polynomial def __mul__ ( self , other ) : \"\"\"Return self * other. The class which is more permissive will be returned. \"\"\" if isinstance ( other , Monomial ) and self and other : return Monomial ( self . coefficient * other . coefficient , self . degree + other . degree ) return super (). __mul__ ( other ) @_extract_polynomial def __rmul__ ( self , other ) : \"\"\"Return other * self. The class which is more permissive will be returned. \"\"\" return self * other def __lt__ ( self , other ) : \"\"\"Return self < other. Compares the degrees of the monomials and then, if they are equal, compares their coefficients. \"\"\" if self . degree == other . degree : return self . a < other . a return self . degree < other . degree def __gt__ ( self , other ) : \"\"\"Return self > other. Compares the degrees of the monomials and then, if they are equal, compares their coefficients. \"\"\" if self . degree == other . degree : return self . a > other . a return self . degree > other . degree def __pow__ ( self , power , modulo = None ) : \"\"\"Return self ** power or pow(self, other, modulo).\"\"\" result = deepcopy ( self ) result **= power return result % modulo if modulo is not None else result def __ipow__ ( self , other ) : \"\"\"Return self **= power. Assumes self is mutable. Does not mutate in the case that self == 0 and other != 1. \"\"\" if not isinstance ( other , int ) : raise ValueError ( \"Can't call Monomial() **= x with a non-integer type.\" ) if other < 0 : raise ValueError ( \"Monomial can only be raised to a non-negative power.\" ) if not self : if other != 0 : return self terms = [ (1, 0) ] else : terms = [ (self.coefficient ** other, self.degree * other) ] # No native option exists to modify Monomial degree . return self . try_set_self ( terms ) def __lshift__ ( self , other ) : \"\"\"Return self << other. Returns a Monomial that is self * x^other. \"\"\" if other < 0 : return self >> - other if not self : return self . zero_instance () return Monomial ( self . coefficient , self . degree + other ) def __ilshift__ ( self , other ) : \"\"\"Return self <<= other. Returns a Monomial that is self * x^other. Does not guarantee the same type is returned. \"\"\" if other < 0 : self >>= - other return self if not self : return self return self . try_set_self ( [ (self.coefficient, self.degree + other) ] ) def __irshift__ ( self , other ) : \"\"\"Return self >>= other.\"\"\" if other < 0 : self <<= - other return self if not self : return self if other > self . degree : return self . try_set_self ( [ (0, 0) ] ) return self . try_set_self ( [ (self.coefficient, self.degree - other) ] ) def __repr__ ( self ) : \"\"\"Return repr(self).\"\"\" deg = max ( 0 , self . degree ) return \"Monomial({0!r}, {1!r})\" . format ( self . coefficient , deg ) def __getitem__ ( self , degree ) : \"\"\"Get the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : return self . _vector [ degree ] if degree == self . degree : return self . _coeff if degree > self . degree or degree < 0 : raise IndexError ( \"Attempt to get coefficient of term with \\ degree {0} of a {1}-degree monomial\" . format ( degree , self . degree )) return 0 def __setitem__ ( self , degree , new_value ) : \"\"\"Set the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : _vector = self . _vector _vector [ degree ] = new_value self . _vector = _vector elif degree == self . degree : self . coefficient = new_value else : raise TermError ( \"Can not set more than 1 term on Monomial.\" )","title":"Monomial"},{"location":"reference/polynomial/core/#ancestors-in-mro_4","text":"polynomial.core.FixedTermPolynomial polynomial.core.Polynomial","title":"Ancestors (in MRO)"},{"location":"reference/polynomial/core/#descendants_3","text":"polynomial.core.Constant","title":"Descendants"},{"location":"reference/polynomial/core/#class-variables_2","text":"valid_term_counts","title":"Class variables"},{"location":"reference/polynomial/core/#static-methods_3","text":"","title":"Static methods"},{"location":"reference/polynomial/core/#zero_instance_3","text":"def zero_instance ( ) Return the Monomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Monomial which is 0.\"\"\" return Monomial ( 0 , 0 )","title":"zero_instance"},{"location":"reference/polynomial/core/#instance-variables_3","text":"coefficient Return the coefficient of the monomial. degree Return the degree of the monomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient.","title":"Instance variables"},{"location":"reference/polynomial/core/#methods_4","text":"","title":"Methods"},{"location":"reference/polynomial/core/#calculate_3","text":"def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms )","title":"calculate"},{"location":"reference/polynomial/core/#nth_derivative_3","text":"def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] )","title":"nth_derivative"},{"location":"reference/polynomial/core/#terms_are_valid_3","text":"def terms_are_valid ( self , terms ) View Source def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) )","title":"terms_are_valid"},{"location":"reference/polynomial/core/#try_set_self_3","text":"def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True )","title":"try_set_self"},{"location":"reference/polynomial/core/#polynomial","text":"class Polynomial ( * args , ** kwargs ) Implements a single-variable mathematical polynomial. View Source class Polynomial : \"\"\"Implements a single-variable mathematical polynomial.\"\"\" @ _ accepts_many_arguments def __ init__ ( self , iterable , from_monomials = False ) : \"\"\"Initialize the polynomial. iterable ::= the coefficients from the highest degree term to the lowest. The method is decorated so that it can accept many *args which it automatically transforms into a single iterable. If the from_monomials flag is True then it can accept many monomials or a single iterable with monomials which altogether add up to form this polynomial. Example usage: Polynomial([1,2,3,4,5]) Polynomial(1,2,3,4,5) Polynomial(range(1, 6)) Polynomial([(1,4), (2,3), (3,2), (4,1), (5,0)], from_monomials=True) Polynomial(((i + 1, 4 - i) for i in range(5)), from_monomials=True) \"\"\" if from_monomials: def monomial_to_tuple ( monomial ) : if isinstance ( monomial , Monomial ) : return monomial . a , monomial . degree if len ( monomial ) == 2 : return monomial raise TypeError ( \"{} cannot be a monomial.\" . format ( monomial )) self . terms = [ monomial_to_tuple ( monomial ) for monomial in iterable ] else : self . _ vector = _ trim ( list ( iterable )[ ::- 1 ]) @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial () def _ trim ( self ) : \"\"\"Trims self._vector to length. Keeps constant terms.\"\"\" self . _ vector = _ trim ( self . _ vector ) @property def degree ( self ) : \"\"\"Return the degree of the polynomial.\"\"\" if not self : return - inf # the degree of the zero polynomial is - infinity return len ( self . _ vector ) - 1 @property def derivative ( self ) : \"\"\"Return a polynomial object which is the derivative of self.\"\"\" return self . nth_derivative () def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c , x in zip ( self , reversed ( factors ))] ) @property def terms ( self ) : \"\"\"Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. \"\"\" s_d = self . degree return [( coeff , s_d - deg ) for deg , coeff in enumerate ( self ) if coeff ! = 0 ] @terms . setter def terms ( self , terms ) : \"\"\"Set the terms of self as a list of tuples in coeff, deg form.\"\"\" if not terms : _ vector = [ 0 ] else : list_len = max ( terms , key = lambda x : x [ 1 ])[ 1 ] + 1 _ vector = [ 0 ] * list_len for coeff , deg in terms : _ vector [ deg ] += coeff _ vector = _ trim ( _ vector ) self . _ vector = _ vector @property def monomials ( self ) : \"\"\"Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. \"\"\" return [ Monomial ( k , deg ) for k , deg in self . terms ] def calculate ( self , x ) : \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms ) def __ getattr__ ( self , name ) : \"\"\"Get coefficient by letter name: ax^n + bx^{n-1} + ... + yx + z.\"\"\" if len ( name ) ! = 1 : return object . __ getattribute__ ( self , name ) if name in string . ascii_letters: return self [ self . degree - ord ( name . lower ()) + ord ( 'a' )] raise AttributeError ( \"attribute {0} is not defined for Polynomial.\" . format ( name )) def __ setattr__ ( self , name , new_value ) : \"\"\"Set coefficient by letter name: ax^n + bx^{n-1} + ... + yx + z.\"\"\" if len ( name ) ! = 1 : object . __ setattr__ ( self , name , new_value ) elif name in string . ascii_letters: self [ self . degree - ord ( name . lower ()) + ord ( 'a' )] = new_value else : raise AttributeError ( \"attribute {0} is not defined for Polynomial.\" . format ( name )) def __ getitem__ ( self , degree ) : \"\"\"Get the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : return self . _ vector [ degree ] if degree == - inf and self . degree == - inf : return 0 if degree > self . degree or degree < 0 : raise IndexError ( \"Attempt to get coefficient of term with \\ degree {0} of a {1}-degree polynomial\" . format ( degree , self . degree )) return self . _ vector [ degree ] def __ setitem__ ( self , degree , new_value ) : \"\"\"Set the coefficient of the term with the given degree.\"\"\" if isinstance ( degree , slice ) : self . _ vector [ degree ] = new_value elif degree == - inf : if self . degree == - inf : self . _ vector = [ new_value ] else : raise IndexError ( \"Can not set term with degree -inf on a\" \" non-zero polynomial.\" ) elif degree > self . degree : raise IndexError ( \"Attempt to set coefficient of term with \\ degree {0} of a {1}-degree polynomial\" . format ( degree , self . degree )) else : self . _ vector [ degree ] = new_value self . _ trim () def __ iter__ ( self ) : \"\"\"Return the coefficients from the highest degree to the lowest.\"\"\" return reversed ( self . _ vector ) def __ repr__ ( self ) : \"\"\"Return repr(self).\"\"\" if not self : return \"Polynomial()\" terms = ', ' . join ([ repr ( ak ) for ak in self ]) return \"Polynomial({0})\" . format ( terms ) def __ str__ ( self ) : \"\"\"Return str(self).\"\"\" if not self : return \"0\" def components ( ak , k , is_leading ) : ak = str ( ak ) if ak [ 0 ] == \"-\" : # Strip - from ak ak = ak [ 1 : ] sign = \"-\" if is_leading else \"- \" else : sign = \"\" if is_leading else \"+ \" # if ak is 1 , the 1 is implicit when raising x to non - zero k , # so strip it . ak = \"\" if ak == \"1\" and k ! = 0 else ak # set x^k portion . if k == 0 : p , k = \"\" , \"\" elif k == 1 : p , k = \"x\" , \"\" else : p = \"x^\" return sign , ak , p , k # 0 : sign , 1 : coeff , 2 : x^ , 3 : a # eg . - 5 x^ 2 s_d = self . degree terms = [ \"{0}{1}{2}{3}\" . format ( * components ( ak , k , k == s_d )) for ak , k in self . terms ] return \" \" . join ( terms ) @ _ extract_polynomial def __ eq__ ( self , other ) : \"\"\"Return self == other. self == 0 <==> self == Polynomial() \"\"\" if other == 0 : return not self return self . degree == other . degree and self . terms == other . terms @ _ extract_polynomial def __ ne__ ( self , other ) : \"\"\"Return self != other. self != 0 <==> self != Polynomial() \"\"\" if other == 0 : return bool ( self ) return self . degree ! = other . degree or self . terms ! = other . terms def __ bool__ ( self ) : \"\"\"Return True if self is not a zero polynomial, otherwise False.\"\"\" self . _ trim () if not self . _ vector : return False if len ( self . _ vector ) > 1 : return True return self . _ vector [ 0 ] ! = 0 @ _ extract_polynomial def __ add__ ( self , other ) : \"\"\"Return self + other.\"\"\" if not self : return deepcopy ( other ) if not other : return deepcopy ( self ) return self . __ class__ (). try_set_self ( _ add ( self . terms , other . terms ) ) @ _ extract_polynomial def __ radd__ ( self , other ) : \"\"\"Return other + self.\"\"\" return self + other @ _ extract_polynomial def __ iadd__ ( self , other ) : \"\"\"Implement self += other.\"\"\" return self . try_set_self ( _ add ( self . terms , other . terms )) @ _ extract_polynomial def __ mul__ ( self , other ) : \"\"\"Return self * other.\"\"\" if not self or not other : return _ get_more_permissive_class ( self , other ). zero_instance () ret_val = deepcopy ( self ) ret_val *= other return ret_val @ _ extract_polynomial def __ rmul__ ( self , other ) : \"\"\"Return other * self.\"\"\" return self * other @ _ extract_polynomial def __ imul__ ( self , other ) : \"\"\"Implement self *= other.\"\"\" return self . try_set_self ( _ mul ( self . terms , other . terms )) def __ pos__ ( self ) : \"\"\"Return +self.\"\"\" self . _ trim () return deepcopy ( self ) def __ neg__ ( self ) : \"\"\"Return -self.\"\"\" ret_val = deepcopy ( self ) ret_val . _ vector = [ - x for x in _ trim ( self . _ vector )] return ret_val @ _ extract_polynomial def __ sub__ ( self , other ) : \"\"\"Return self - other.\"\"\" return self + ( - other ) @ _ extract_polynomial def __ rsub__ ( self , other ) : \"\"\"Return other - self.\"\"\" return other + ( - self ) @ _ extract_polynomial def __ isub__ ( self , other ) : \"\"\"Implement self -= other.\"\"\" return self . try_set_self ( _ sub ( self . terms , other . terms )) @ _ extract_polynomial def __ ifloordiv__ ( self , other ) : \"\"\"Return self //= other.\"\"\" return self . try_set_self ( divmod ( self , other )[ 0 ]. terms ) @ _ extract_polynomial def __ floordiv__ ( self , other ) : \"\"\"Return self // other.\"\"\" return divmod ( self , other )[ 0 ] @ _ extract_polynomial def __ imod__ ( self , other ) : \"\"\"Return self %= other.\"\"\" return self . try_set_self ( divmod ( self , other )[ 1 ]. terms ) @ _ extract_polynomial def __ mod__ ( self , other ) : \"\"\"Return self % other.\"\"\" return divmod ( self , other )[ 1 ] @ _ extract_polynomial def __ divmod__ ( self , other ) : \"\"\"Return divmod(self, other). The remainder is any term that would have degree < 0. \"\"\" if other . degree == - inf : raise ZeroDivisionError ( \"Can't divide a Polynomial by 0\" ) if isinstance ( other , Monomial ) : vec = self . _ vector [ other . degree :] remainder = self . _ vector [ :other . degree ] for i , v in enumerate ( vec ) : vec [ i ] = v / other . a return Polynomial ( vec [ ::- 1 ]), Polynomial ( remainder [ ::- 1 ]) working = self . terms wd0 = _ degree ( working ) other_terms = other . terms other_deg = other . degree vec = [] while wd0 >= other_deg: val = working [ 0 ][ 0 ] / other . a wd = wd0 working = _ sub ( working , _ mul ( other_terms , [( val , wd - other_deg )])) wd0 = _ degree ( working ) vec . append (( val , wd - other_deg if wd0 ! = - inf else 0 )) return ( Polynomial ( vec , from_monomials = True ), Polynomial ( working , from_monomials = True ) ) def __ pow__ ( self , power , modulo = None ) : \"\"\"Return self ** power or pow(self, other, modulo).\"\"\" if not isinstance ( power , int ) : raise ValueError ( \"Can't call Polynomial() ** x with a non-integer type.\" ) if power < 0 : raise ValueError ( \"Polynomial can only be raised to a non-negative power.\" ) if power == 0 : result = Constant ( 1 ) elif power % 2 == 1: result = Polynomial ( self ) if power > 1 : result *= ( self ** ( power // 2 )) ** 2 else : if power == 2 : result = Polynomial ( self ) else : result = self ** ( power // 2 ) result *= result return result % modulo if modulo is not None else result def __ ipow__ ( self , other ) : \"\"\"Return self **= power.\"\"\" terms = ( self ** other ). terms return self . try_set_self ( terms ) def __ lshift__ ( self , other ) : \"\"\"Return self << other. Increases the degree of each term by other. \"\"\" ret = deepcopy ( self ) ret <<= other return ret def __ ilshift__ ( self , other ) : \"\"\"Return self <<= other. Increases the degree of each term by other. \"\"\" if other < 0 : self >>= - other else : self . _ vector = [ 0 ] * other + self . _ vector return self def __ rshift__ ( self , other ) : \"\"\"Return self >> other. Decreases the degree of each term by other. \"\"\" ret = deepcopy ( self ) ret >>= other return ret def __ irshift__ ( self , other ) : \"\"\"Return self >>= other. Decreases the degree of each term by other. \"\"\" if other < 0 : self <<= - other else : self . _ vector = _ trim ( self . _ vector [ other :]) return self def __ contains__ ( self , item ) : \"\"\"Return item in self. Requires item to be a tuple, list of tuples, a set of tuples, or a Polynomial. Each tuple should contain two values, the first being the coefficient and the second being the degree. \"\"\" if isinstance ( item , tuple ) : return item in self . terms if isinstance ( item , list ) : return set ( item ). issubset ( self . terms ) if isinstance ( item , set ) : return item . issubset ( self . terms ) if isinstance ( item , Polynomial ) : return set ( item . terms ). issubset ( self . terms ) raise ValueError ( \"Can not check {0} for membership. A two-tuple, list of \" \"two-tuples, a set, or a Polynomial are required.\" . format ( type ( item ). __ name__ ) ) def terms_are_valid ( self , terms ) : \"\"\"Return true if the terms are valid.\"\"\" return True def try_set_self ( self , terms ) : \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ) : self . terms = terms return self return Polynomial ( terms , from_monomials = True )","title":"Polynomial"},{"location":"reference/polynomial/core/#descendants_4","text":"polynomial.core.FixedDegreePolynomial polynomial.core.FixedTermPolynomial polynomial.frozen.FrozenPolynomial","title":"Descendants"},{"location":"reference/polynomial/core/#static-methods_4","text":"","title":"Static methods"},{"location":"reference/polynomial/core/#zero_instance_4","text":"def zero_instance ( ) Return the Polynomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial ()","title":"zero_instance"},{"location":"reference/polynomial/core/#instance-variables_4","text":"degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient.","title":"Instance variables"},{"location":"reference/polynomial/core/#methods_5","text":"","title":"Methods"},{"location":"reference/polynomial/core/#calculate_4","text":"def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms )","title":"calculate"},{"location":"reference/polynomial/core/#nth_derivative_4","text":"def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] )","title":"nth_derivative"},{"location":"reference/polynomial/core/#terms_are_valid_4","text":"def terms_are_valid ( self , terms ) Return true if the terms are valid. View Source def terms_are_valid ( self , terms ): \"\"\"Return true if the terms are valid.\"\"\" return True","title":"terms_are_valid"},{"location":"reference/polynomial/core/#try_set_self_4","text":"def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True )","title":"try_set_self"},{"location":"reference/polynomial/core/#polynomialerror","text":"class PolynomialError ( / , * args , ** kwargs ) Raised when a Polynomial encounters an error. View Source class PolynomialError ( Exception ): \"\"\"Raised when a Polynomial encounters an error.\"\"\"","title":"PolynomialError"},{"location":"reference/polynomial/core/#ancestors-in-mro_5","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/polynomial/core/#descendants_5","text":"polynomial.core.DegreeError polynomial.core.TermError","title":"Descendants"},{"location":"reference/polynomial/core/#class-variables_3","text":"args","title":"Class variables"},{"location":"reference/polynomial/core/#methods_6","text":"","title":"Methods"},{"location":"reference/polynomial/core/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/polynomial/core/#termerror","text":"class TermError ( / , * args , ** kwargs ) Raised when a Polynomial's term count changes. View Source class TermError ( PolynomialError ): \"\"\"Raised when a Polynomial's term count changes.\"\"\"","title":"TermError"},{"location":"reference/polynomial/core/#ancestors-in-mro_6","text":"polynomial.core.PolynomialError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/polynomial/core/#class-variables_4","text":"args","title":"Class variables"},{"location":"reference/polynomial/core/#methods_7","text":"","title":"Methods"},{"location":"reference/polynomial/core/#with_traceback_2","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/polynomial/frozen/","text":"Module polynomial.frozen This module defines the Freezable interface and subclasses. View Source \"\"\"This module defines the Freezable interface and subclasses.\"\"\" from math import inf from polynomial.core import ( Constant , Polynomial , _extract_polynomial , ) class Freezable : \"\"\"An interface for freezable objects.\"\"\" def _freeze ( self ): \"\"\"Prevent further modification of self.\"\"\" if not self . _is_frozen (): self . _frozen = True def _is_frozen ( self ): \"\"\"Return true if self is frozen.\"\"\" return getattr ( self , \"_frozen\" , False ) def __setitem__ ( self , key , value ): \"\"\"Implement self[x] = y; disallows setting item if frozen.\"\"\" if self . _is_frozen (): raise AttributeError ( \"Can not modify items of frozen object.\" ) super () . __setitem__ ( key , value ) def __setattr__ ( self , key , value ): \"\"\"Implement self.x; disallows setting attr if frozen.\"\"\" if not self . _is_frozen (): object . __setattr__ ( self , key , value ) else : raise AttributeError ( \"Can not modify frozen object.\" ) def _no_op ( self ): \"\"\"Do nothing. Used as a dummy method.\"\"\" class FrozenPolynomial ( Freezable , Polynomial ): \"\"\"A polynomial which can not be directly modified.\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Create a polynomial from the args, and then freeze it.\"\"\" Polynomial . __init__ ( self , * args , ** kwargs ) self . _vector = tuple ( self . _vector ) self . _trim = self . _no_op self . _freeze () @classmethod def zero_instance ( cls ): \"\"\"Return the zero FrozenPolynomial.\"\"\" return FrozenPolynomial () @classmethod def from_polynomial ( cls , polynomial ): \"\"\"Create a frozen copy of the polynomial.\"\"\" return cls ( polynomial ) def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" return \"Frozen\" + super () . __repr__ () def __hash__ ( self ): \"\"\"Return hash(self). Equal to the hash of a tuple with the coefficients sorted by their degree descendingly. \"\"\" return hash ( self . _vector ) class ZeroPolynomial ( Freezable , Constant , valid_degrees =- inf ): \"\"\"The zero polynomial.\"\"\" # Never used, since we would raise errors due to Freezable # anyways. valid_term_counts = ( 0 , ) def __init__ ( self ): \"\"\"Equivalent to Polynomial().\"\"\" Constant . __init__ ( self , 0 ) self . _trim = self . _no_op self . _freeze () @property def _vector ( self ): \"\"\"Return self._vector.\"\"\" return ( 0 , ) @property def degree ( self ): \"\"\"Return self.degree.\"\"\" return - inf @classmethod def zero_instance ( cls ): \"\"\"Return an instance of the ZeroPolynomial.\"\"\" return ZeroPolynomial () @property def const ( self ): \"\"\"Return self.const, which is always 0.\"\"\" return 0 @_extract_polynomial def __mul__ ( self , other ): \"\"\"Return self * other.\"\"\" return other . zero_instance () @_extract_polynomial def __rmul__ ( self , other ): \"\"\"Return other * self.\"\"\" return other . zero_instance () def __ipow__ ( self , other ): \"\"\"Return self **= power. Does not mutate self. \"\"\" if other == 0 : return Constant ( 1 ) # This call simply enforces other >= 0 and is int. # Could be moved out into a decorator. super () . __ipow__ ( other ) return ZeroPolynomial () def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" return \"ZeroPolynomial()\" def __hash__ ( self ): \"\"\"Return hash(self). Equal to the hash of an empty tuple.\"\"\" return hash ( tuple ()) Variables inf Classes Freezable class Freezable ( / , * args , ** kwargs ) An interface for freezable objects. View Source class Freezable : \"\"\"An interface for freezable objects.\"\"\" def _freeze ( self ) : \"\"\"Prevent further modification of self.\"\"\" if not self . _is_frozen () : self . _frozen = True def _is_frozen ( self ) : \"\"\"Return true if self is frozen.\"\"\" return getattr ( self , \"_frozen\" , False ) def __setitem__ ( self , key , value ) : \"\"\"Implement self[x] = y; disallows setting item if frozen.\"\"\" if self . _is_frozen () : raise AttributeError ( \"Can not modify items of frozen object.\" ) super (). __setitem__ ( key , value ) def __setattr__ ( self , key , value ) : \"\"\"Implement self.x; disallows setting attr if frozen.\"\"\" if not self . _is_frozen () : object . __setattr__ ( self , key , value ) else : raise AttributeError ( \"Can not modify frozen object.\" ) def _no_op ( self ) : \"\"\"Do nothing. Used as a dummy method.\"\"\" Descendants polynomial.frozen.FrozenPolynomial polynomial.frozen.ZeroPolynomial FrozenPolynomial class FrozenPolynomial ( * args , ** kwargs ) A polynomial which can not be directly modified. View Source class FrozenPolynomial ( Freezable , Polynomial ) : \"\"\"A polynomial which can not be directly modified.\"\"\" def __init__ ( self , * args , ** kwargs ) : \"\"\"Create a polynomial from the args, and then freeze it.\"\"\" Polynomial . __init__ ( self , * args , ** kwargs ) self . _vector = tuple ( self . _vector ) self . _trim = self . _no_op self . _freeze () @classmethod def zero_instance ( cls ) : \"\"\"Return the zero FrozenPolynomial.\"\"\" return FrozenPolynomial () @classmethod def from_polynomial ( cls , polynomial ) : \"\"\"Create a frozen copy of the polynomial.\"\"\" return cls ( polynomial ) def __repr__ ( self ) : \"\"\"Return repr(self).\"\"\" return \"Frozen\" + super (). __repr__ () def __hash__ ( self ) : \"\"\"Return hash(self). Equal to the hash of a tuple with the coefficients sorted by their degree descendingly. \"\"\" return hash ( self . _vector ) Ancestors (in MRO) polynomial.frozen.Freezable polynomial.core.Polynomial Static methods from_polynomial def from_polynomial ( polynomial ) Create a frozen copy of the polynomial. View Source @classmethod def from_polynomial ( cls , polynomial ) : \"\"\"Create a frozen copy of the polynomial.\"\"\" return cls ( polynomial ) zero_instance def zero_instance ( ) Return the zero FrozenPolynomial. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the zero FrozenPolynomial.\"\"\" return FrozenPolynomial () Instance variables degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. Methods calculate def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms ) nth_derivative def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] ) terms_are_valid def terms_are_valid ( self , terms ) Return true if the terms are valid. View Source def terms_are_valid ( self , terms ): \"\"\"Return true if the terms are valid.\"\"\" return True try_set_self def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True ) ZeroPolynomial class ZeroPolynomial ( ) The zero polynomial. View Source class ZeroPolynomial ( Freezable , Constant , valid_degrees =- inf ): \"\"\"The zero polynomial.\"\"\" # Never used, since we would raise errors due to Freezable # anyways. valid_term_counts = ( 0 , ) def __init__ ( self ): \"\"\"Equivalent to Polynomial().\"\"\" Constant . __init__ ( self , 0 ) self . _trim = self . _no_op self . _freeze () @ property def _vector ( self ): \"\"\"Return self._vector.\"\"\" return ( 0 , ) @ property def degree ( self ): \"\"\"Return self.degree.\"\"\" return - inf @ classmethod def zero_instance ( cls ): \"\"\"Return an instance of the ZeroPolynomial.\"\"\" return ZeroPolynomial () @ property def const ( self ): \"\"\"Return self.const, which is always 0.\"\"\" return 0 @ _extract_polynomial def __mul__ ( self , other ): \"\"\"Return self * other.\"\"\" return other . zero_instance () @ _extract_polynomial def __rmul__ ( self , other ): \"\"\"Return other * self.\"\"\" return other . zero_instance () def __ipow__ ( self , other ): \"\"\"Return self **= power. Does not mutate self. \"\"\" if other == 0 : return Constant ( 1 ) # This call simply enforces other >= 0 and is int. # Could be moved out into a decorator. super () . __ipow__ ( other ) return ZeroPolynomial () def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" return \"ZeroPolynomial()\" def __hash__ ( self ): \"\"\"Return hash(self). Equal to the hash of an empty tuple.\"\"\" return hash ( tuple ()) Ancestors (in MRO) polynomial.frozen.Freezable polynomial.core.Constant polynomial.core.FixedDegreePolynomial polynomial.core.Monomial polynomial.core.FixedTermPolynomial polynomial.core.Polynomial Class variables valid_degrees valid_term_counts Static methods zero_instance def zero_instance ( ) Return an instance of the ZeroPolynomial. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return an instance of the ZeroPolynomial.\"\"\" return ZeroPolynomial () Instance variables coefficient Return the coefficient of the monomial. const Return self.const, which is always 0. degree Return self.degree. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. Methods calculate def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms ) nth_derivative def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] ) terms_are_valid def terms_are_valid ( self , terms ) View Source def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) ) try_set_self def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True )","title":"Frozen"},{"location":"reference/polynomial/frozen/#module-polynomialfrozen","text":"This module defines the Freezable interface and subclasses. View Source \"\"\"This module defines the Freezable interface and subclasses.\"\"\" from math import inf from polynomial.core import ( Constant , Polynomial , _extract_polynomial , ) class Freezable : \"\"\"An interface for freezable objects.\"\"\" def _freeze ( self ): \"\"\"Prevent further modification of self.\"\"\" if not self . _is_frozen (): self . _frozen = True def _is_frozen ( self ): \"\"\"Return true if self is frozen.\"\"\" return getattr ( self , \"_frozen\" , False ) def __setitem__ ( self , key , value ): \"\"\"Implement self[x] = y; disallows setting item if frozen.\"\"\" if self . _is_frozen (): raise AttributeError ( \"Can not modify items of frozen object.\" ) super () . __setitem__ ( key , value ) def __setattr__ ( self , key , value ): \"\"\"Implement self.x; disallows setting attr if frozen.\"\"\" if not self . _is_frozen (): object . __setattr__ ( self , key , value ) else : raise AttributeError ( \"Can not modify frozen object.\" ) def _no_op ( self ): \"\"\"Do nothing. Used as a dummy method.\"\"\" class FrozenPolynomial ( Freezable , Polynomial ): \"\"\"A polynomial which can not be directly modified.\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Create a polynomial from the args, and then freeze it.\"\"\" Polynomial . __init__ ( self , * args , ** kwargs ) self . _vector = tuple ( self . _vector ) self . _trim = self . _no_op self . _freeze () @classmethod def zero_instance ( cls ): \"\"\"Return the zero FrozenPolynomial.\"\"\" return FrozenPolynomial () @classmethod def from_polynomial ( cls , polynomial ): \"\"\"Create a frozen copy of the polynomial.\"\"\" return cls ( polynomial ) def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" return \"Frozen\" + super () . __repr__ () def __hash__ ( self ): \"\"\"Return hash(self). Equal to the hash of a tuple with the coefficients sorted by their degree descendingly. \"\"\" return hash ( self . _vector ) class ZeroPolynomial ( Freezable , Constant , valid_degrees =- inf ): \"\"\"The zero polynomial.\"\"\" # Never used, since we would raise errors due to Freezable # anyways. valid_term_counts = ( 0 , ) def __init__ ( self ): \"\"\"Equivalent to Polynomial().\"\"\" Constant . __init__ ( self , 0 ) self . _trim = self . _no_op self . _freeze () @property def _vector ( self ): \"\"\"Return self._vector.\"\"\" return ( 0 , ) @property def degree ( self ): \"\"\"Return self.degree.\"\"\" return - inf @classmethod def zero_instance ( cls ): \"\"\"Return an instance of the ZeroPolynomial.\"\"\" return ZeroPolynomial () @property def const ( self ): \"\"\"Return self.const, which is always 0.\"\"\" return 0 @_extract_polynomial def __mul__ ( self , other ): \"\"\"Return self * other.\"\"\" return other . zero_instance () @_extract_polynomial def __rmul__ ( self , other ): \"\"\"Return other * self.\"\"\" return other . zero_instance () def __ipow__ ( self , other ): \"\"\"Return self **= power. Does not mutate self. \"\"\" if other == 0 : return Constant ( 1 ) # This call simply enforces other >= 0 and is int. # Could be moved out into a decorator. super () . __ipow__ ( other ) return ZeroPolynomial () def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" return \"ZeroPolynomial()\" def __hash__ ( self ): \"\"\"Return hash(self). Equal to the hash of an empty tuple.\"\"\" return hash ( tuple ())","title":"Module polynomial.frozen"},{"location":"reference/polynomial/frozen/#variables","text":"inf","title":"Variables"},{"location":"reference/polynomial/frozen/#classes","text":"","title":"Classes"},{"location":"reference/polynomial/frozen/#freezable","text":"class Freezable ( / , * args , ** kwargs ) An interface for freezable objects. View Source class Freezable : \"\"\"An interface for freezable objects.\"\"\" def _freeze ( self ) : \"\"\"Prevent further modification of self.\"\"\" if not self . _is_frozen () : self . _frozen = True def _is_frozen ( self ) : \"\"\"Return true if self is frozen.\"\"\" return getattr ( self , \"_frozen\" , False ) def __setitem__ ( self , key , value ) : \"\"\"Implement self[x] = y; disallows setting item if frozen.\"\"\" if self . _is_frozen () : raise AttributeError ( \"Can not modify items of frozen object.\" ) super (). __setitem__ ( key , value ) def __setattr__ ( self , key , value ) : \"\"\"Implement self.x; disallows setting attr if frozen.\"\"\" if not self . _is_frozen () : object . __setattr__ ( self , key , value ) else : raise AttributeError ( \"Can not modify frozen object.\" ) def _no_op ( self ) : \"\"\"Do nothing. Used as a dummy method.\"\"\"","title":"Freezable"},{"location":"reference/polynomial/frozen/#descendants","text":"polynomial.frozen.FrozenPolynomial polynomial.frozen.ZeroPolynomial","title":"Descendants"},{"location":"reference/polynomial/frozen/#frozenpolynomial","text":"class FrozenPolynomial ( * args , ** kwargs ) A polynomial which can not be directly modified. View Source class FrozenPolynomial ( Freezable , Polynomial ) : \"\"\"A polynomial which can not be directly modified.\"\"\" def __init__ ( self , * args , ** kwargs ) : \"\"\"Create a polynomial from the args, and then freeze it.\"\"\" Polynomial . __init__ ( self , * args , ** kwargs ) self . _vector = tuple ( self . _vector ) self . _trim = self . _no_op self . _freeze () @classmethod def zero_instance ( cls ) : \"\"\"Return the zero FrozenPolynomial.\"\"\" return FrozenPolynomial () @classmethod def from_polynomial ( cls , polynomial ) : \"\"\"Create a frozen copy of the polynomial.\"\"\" return cls ( polynomial ) def __repr__ ( self ) : \"\"\"Return repr(self).\"\"\" return \"Frozen\" + super (). __repr__ () def __hash__ ( self ) : \"\"\"Return hash(self). Equal to the hash of a tuple with the coefficients sorted by their degree descendingly. \"\"\" return hash ( self . _vector )","title":"FrozenPolynomial"},{"location":"reference/polynomial/frozen/#ancestors-in-mro","text":"polynomial.frozen.Freezable polynomial.core.Polynomial","title":"Ancestors (in MRO)"},{"location":"reference/polynomial/frozen/#static-methods","text":"","title":"Static methods"},{"location":"reference/polynomial/frozen/#from_polynomial","text":"def from_polynomial ( polynomial ) Create a frozen copy of the polynomial. View Source @classmethod def from_polynomial ( cls , polynomial ) : \"\"\"Create a frozen copy of the polynomial.\"\"\" return cls ( polynomial )","title":"from_polynomial"},{"location":"reference/polynomial/frozen/#zero_instance","text":"def zero_instance ( ) Return the zero FrozenPolynomial. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the zero FrozenPolynomial.\"\"\" return FrozenPolynomial ()","title":"zero_instance"},{"location":"reference/polynomial/frozen/#instance-variables","text":"degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient.","title":"Instance variables"},{"location":"reference/polynomial/frozen/#methods","text":"","title":"Methods"},{"location":"reference/polynomial/frozen/#calculate","text":"def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms )","title":"calculate"},{"location":"reference/polynomial/frozen/#nth_derivative","text":"def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] )","title":"nth_derivative"},{"location":"reference/polynomial/frozen/#terms_are_valid","text":"def terms_are_valid ( self , terms ) Return true if the terms are valid. View Source def terms_are_valid ( self , terms ): \"\"\"Return true if the terms are valid.\"\"\" return True","title":"terms_are_valid"},{"location":"reference/polynomial/frozen/#try_set_self","text":"def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True )","title":"try_set_self"},{"location":"reference/polynomial/frozen/#zeropolynomial","text":"class ZeroPolynomial ( ) The zero polynomial. View Source class ZeroPolynomial ( Freezable , Constant , valid_degrees =- inf ): \"\"\"The zero polynomial.\"\"\" # Never used, since we would raise errors due to Freezable # anyways. valid_term_counts = ( 0 , ) def __init__ ( self ): \"\"\"Equivalent to Polynomial().\"\"\" Constant . __init__ ( self , 0 ) self . _trim = self . _no_op self . _freeze () @ property def _vector ( self ): \"\"\"Return self._vector.\"\"\" return ( 0 , ) @ property def degree ( self ): \"\"\"Return self.degree.\"\"\" return - inf @ classmethod def zero_instance ( cls ): \"\"\"Return an instance of the ZeroPolynomial.\"\"\" return ZeroPolynomial () @ property def const ( self ): \"\"\"Return self.const, which is always 0.\"\"\" return 0 @ _extract_polynomial def __mul__ ( self , other ): \"\"\"Return self * other.\"\"\" return other . zero_instance () @ _extract_polynomial def __rmul__ ( self , other ): \"\"\"Return other * self.\"\"\" return other . zero_instance () def __ipow__ ( self , other ): \"\"\"Return self **= power. Does not mutate self. \"\"\" if other == 0 : return Constant ( 1 ) # This call simply enforces other >= 0 and is int. # Could be moved out into a decorator. super () . __ipow__ ( other ) return ZeroPolynomial () def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" return \"ZeroPolynomial()\" def __hash__ ( self ): \"\"\"Return hash(self). Equal to the hash of an empty tuple.\"\"\" return hash ( tuple ())","title":"ZeroPolynomial"},{"location":"reference/polynomial/frozen/#ancestors-in-mro_1","text":"polynomial.frozen.Freezable polynomial.core.Constant polynomial.core.FixedDegreePolynomial polynomial.core.Monomial polynomial.core.FixedTermPolynomial polynomial.core.Polynomial","title":"Ancestors (in MRO)"},{"location":"reference/polynomial/frozen/#class-variables","text":"valid_degrees valid_term_counts","title":"Class variables"},{"location":"reference/polynomial/frozen/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/polynomial/frozen/#zero_instance_1","text":"def zero_instance ( ) Return an instance of the ZeroPolynomial. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return an instance of the ZeroPolynomial.\"\"\" return ZeroPolynomial ()","title":"zero_instance"},{"location":"reference/polynomial/frozen/#instance-variables_1","text":"coefficient Return the coefficient of the monomial. const Return self.const, which is always 0. degree Return self.degree. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient.","title":"Instance variables"},{"location":"reference/polynomial/frozen/#methods_1","text":"","title":"Methods"},{"location":"reference/polynomial/frozen/#calculate_1","text":"def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms )","title":"calculate"},{"location":"reference/polynomial/frozen/#nth_derivative_1","text":"def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] )","title":"nth_derivative"},{"location":"reference/polynomial/frozen/#terms_are_valid_1","text":"def terms_are_valid ( self , terms ) View Source def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) )","title":"terms_are_valid"},{"location":"reference/polynomial/frozen/#try_set_self_1","text":"def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True )","title":"try_set_self"},{"location":"reference/polynomial/trinomial/","text":"Module polynomial.trinomial This module defines different types of trinomials and their methods. View Source \"\"\"This module defines different types of trinomials and their methods.\"\"\" from polynomial.core import ( Polynomial , Monomial , Constant , FixedDegreePolynomial , FixedTermPolynomial ) from math import sqrt class Trinomial ( FixedTermPolynomial , valid_term_counts = ( 0 , 1 , 2 , 3 )): \"\"\"Implements single-variable mathematical trinomials.\"\"\" def __init__ ( self , monomial1 = None , monomial2 = None , monomial3 = None ): \"\"\"Initialize the trinomial with 3 monomials. The arguments can also be 2-tuples in the form: (coefficient, degree) \"\"\" if not monomial1 : monomial1 = Monomial ( 1 , 1 ) if not monomial2 : monomial2 = Monomial ( 1 , 2 ) if not monomial3 : monomial3 = Monomial ( 1 , 3 ) args = [ monomial1 , monomial2 , monomial3 ] Polynomial . __init__ ( self , args , from_monomials = True ) def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" terms = self . terms assert len ( terms ) == 3 t1 , t2 , t3 = terms return ( \"Trinomial(Monomial({0}, {1}), Monomial({2}, {3}), \" \"Monomial({4}, {5}))\" . format ( * t1 , * t2 , * t3 ) ) class QuadraticTrinomial ( FixedDegreePolynomial , Trinomial , valid_degrees = 2 ): \"\"\"Implements quadratic trinomials and their related methods.\"\"\" def __init__ ( self , a = 1 , b = 1 , c = 1 ): \"\"\"Initialize the trinomial as ax^2 + bx + c.\"\"\" if a == 0 : raise ValueError ( \"Object not a quadratic trinomial since a==0!\" ) Polynomial . __init__ ( self , a , b , c ) @property def discriminant ( self ): \"\"\"Return the discriminant of ax^2 + bx + c = 0.\"\"\" c , b , a = self . _vector return b * b - 4 * a * c @property def complex_roots ( self ): \"\"\"Return a 2-tuple with the 2 complex roots of ax^2 + bx + c = 0. + root is first, - root is second. \"\"\" c , b , a = self . _vector D = b * b - 4 * a * c sqrtD = sqrt ( D ) if D >= 0 else sqrt ( - D ) * 1j a = a * 2 return ( - b + sqrtD ) / a , ( - b - sqrtD ) / a @property def real_roots ( self ): \"\"\"Return a 2-tuple with the real roots if self.discriminant>=0. Return an empty tuple otherwise. \"\"\" if self . discriminant < 0 : return tuple () return self . complex_roots @property def complex_factors ( self ): \"\"\"Return (a, (x-x_0), (x-x_1)), where x_0 and x_1 are the roots.\"\"\" roots = self . complex_roots return ( Constant ( self . a ), Polynomial ([ 1 , - roots [ 0 ]]), Polynomial ([ 1 , - roots [ 1 ]])) @property def real_factors ( self ): \"\"\"Return (self,) if D < 0. Return the factors otherwise.\"\"\" if self . discriminant < 0 : return ( self ,) return self . complex_factors def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" return ( \"QuadraticTrinomial({0!r}, {1!r}, {2!r})\" . format ( self . a , self . b , self . c ) ) Classes QuadraticTrinomial class QuadraticTrinomial ( a = 1 , b = 1 , c = 1 ) Implements quadratic trinomials and their related methods. View Source class QuadraticTrinomial ( FixedDegreePolynomial , Trinomial , valid_degrees = 2 ) : \"\"\"Implements quadratic trinomials and their related methods.\"\"\" def __init__ ( self , a = 1 , b = 1 , c = 1 ) : \"\"\"Initialize the trinomial as ax^2 + bx + c.\"\"\" if a == 0 : raise ValueError ( \"Object not a quadratic trinomial since a==0!\" ) Polynomial . __init__ ( self , a , b , c ) @property def discriminant ( self ) : \"\"\"Return the discriminant of ax^2 + bx + c = 0.\"\"\" c , b , a = self . _vector return b * b - 4 * a * c @property def complex_roots ( self ) : \"\"\"Return a 2-tuple with the 2 complex roots of ax^2 + bx + c = 0. + root is first, - root is second. \"\"\" c , b , a = self . _vector D = b * b - 4 * a * c sqrtD = sqrt ( D ) if D >= 0 else sqrt ( - D ) * 1 j a = a * 2 return ( - b + sqrtD ) / a , ( - b - sqrtD ) / a @property def real_roots ( self ) : \"\"\"Return a 2-tuple with the real roots if self.discriminant>=0. Return an empty tuple otherwise. \"\"\" if self . discriminant < 0 : return tuple () return self . complex_roots @property def complex_factors ( self ) : \"\"\"Return (a, (x-x_0), (x-x_1)), where x_0 and x_1 are the roots.\"\"\" roots = self . complex_roots return ( Constant ( self . a ), Polynomial ( [ 1, -roots[0 ] ] ), Polynomial ( [ 1, -roots[1 ] ] )) @property def real_factors ( self ) : \"\"\"Return (self,) if D < 0. Return the factors otherwise.\"\"\" if self . discriminant < 0 : return ( self ,) return self . complex_factors def __repr__ ( self ) : \"\"\"Return repr(self).\"\"\" return ( \"QuadraticTrinomial({0!r}, {1!r}, {2!r})\" . format ( self . a , self . b , self . c ) ) Ancestors (in MRO) polynomial.core.FixedDegreePolynomial polynomial.trinomial.Trinomial polynomial.core.FixedTermPolynomial polynomial.core.Polynomial Class variables valid_degrees valid_term_counts Static methods zero_instance def zero_instance ( ) Return the Polynomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial () Instance variables complex_factors Return (a, (x-x_0), (x-x_1)), where x_0 and x_1 are the roots. complex_roots Return a 2-tuple with the 2 complex roots of ax^2 + bx + c = 0. root is first, - root is second. degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. discriminant Return the discriminant of ax^2 + bx + c = 0. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. real_factors Return (self,) if D < 0. Return the factors otherwise. real_roots Return a 2-tuple with the real roots if self.discriminant>=0. Return an empty tuple otherwise. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. Methods calculate def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms ) nth_derivative def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] ) terms_are_valid def terms_are_valid ( self , terms ) View Source def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) ) try_set_self def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True ) Trinomial class Trinomial ( monomial1 = None , monomial2 = None , monomial3 = None ) Implements single-variable mathematical trinomials. View Source class Trinomial ( FixedTermPolynomial , valid_term_counts = ( 0 , 1 , 2 , 3 )): \"\"\"Implements single-variable mathematical trinomials.\"\"\" def __init__ ( self , monomial1 = None , monomial2 = None , monomial3 = None ): \"\"\"Initialize the trinomial with 3 monomials. The arguments can also be 2-tuples in the form: (coefficient, degree) \"\"\" if not monomial1 : monomial1 = Monomial ( 1 , 1 ) if not monomial2 : monomial2 = Monomial ( 1 , 2 ) if not monomial3 : monomial3 = Monomial ( 1 , 3 ) args = [ monomial1 , monomial2 , monomial3 ] Polynomial . __init__ ( self , args , from_monomials = True ) def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" terms = self . terms assert len ( terms ) == 3 t1 , t2 , t3 = terms return ( \"Trinomial(Monomial({0}, {1}), Monomial({2}, {3}), \" \"Monomial({4}, {5}))\" . format ( * t1 , * t2 , * t3 ) ) Ancestors (in MRO) polynomial.core.FixedTermPolynomial polynomial.core.Polynomial Descendants polynomial.trinomial.QuadraticTrinomial Class variables valid_term_counts Static methods zero_instance def zero_instance ( ) Return the Polynomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial () Instance variables degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient. Methods calculate def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms ) nth_derivative def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] ) terms_are_valid def terms_are_valid ( self , terms ) View Source def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) ) try_set_self def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True )","title":"Trinomial"},{"location":"reference/polynomial/trinomial/#module-polynomialtrinomial","text":"This module defines different types of trinomials and their methods. View Source \"\"\"This module defines different types of trinomials and their methods.\"\"\" from polynomial.core import ( Polynomial , Monomial , Constant , FixedDegreePolynomial , FixedTermPolynomial ) from math import sqrt class Trinomial ( FixedTermPolynomial , valid_term_counts = ( 0 , 1 , 2 , 3 )): \"\"\"Implements single-variable mathematical trinomials.\"\"\" def __init__ ( self , monomial1 = None , monomial2 = None , monomial3 = None ): \"\"\"Initialize the trinomial with 3 monomials. The arguments can also be 2-tuples in the form: (coefficient, degree) \"\"\" if not monomial1 : monomial1 = Monomial ( 1 , 1 ) if not monomial2 : monomial2 = Monomial ( 1 , 2 ) if not monomial3 : monomial3 = Monomial ( 1 , 3 ) args = [ monomial1 , monomial2 , monomial3 ] Polynomial . __init__ ( self , args , from_monomials = True ) def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" terms = self . terms assert len ( terms ) == 3 t1 , t2 , t3 = terms return ( \"Trinomial(Monomial({0}, {1}), Monomial({2}, {3}), \" \"Monomial({4}, {5}))\" . format ( * t1 , * t2 , * t3 ) ) class QuadraticTrinomial ( FixedDegreePolynomial , Trinomial , valid_degrees = 2 ): \"\"\"Implements quadratic trinomials and their related methods.\"\"\" def __init__ ( self , a = 1 , b = 1 , c = 1 ): \"\"\"Initialize the trinomial as ax^2 + bx + c.\"\"\" if a == 0 : raise ValueError ( \"Object not a quadratic trinomial since a==0!\" ) Polynomial . __init__ ( self , a , b , c ) @property def discriminant ( self ): \"\"\"Return the discriminant of ax^2 + bx + c = 0.\"\"\" c , b , a = self . _vector return b * b - 4 * a * c @property def complex_roots ( self ): \"\"\"Return a 2-tuple with the 2 complex roots of ax^2 + bx + c = 0. + root is first, - root is second. \"\"\" c , b , a = self . _vector D = b * b - 4 * a * c sqrtD = sqrt ( D ) if D >= 0 else sqrt ( - D ) * 1j a = a * 2 return ( - b + sqrtD ) / a , ( - b - sqrtD ) / a @property def real_roots ( self ): \"\"\"Return a 2-tuple with the real roots if self.discriminant>=0. Return an empty tuple otherwise. \"\"\" if self . discriminant < 0 : return tuple () return self . complex_roots @property def complex_factors ( self ): \"\"\"Return (a, (x-x_0), (x-x_1)), where x_0 and x_1 are the roots.\"\"\" roots = self . complex_roots return ( Constant ( self . a ), Polynomial ([ 1 , - roots [ 0 ]]), Polynomial ([ 1 , - roots [ 1 ]])) @property def real_factors ( self ): \"\"\"Return (self,) if D < 0. Return the factors otherwise.\"\"\" if self . discriminant < 0 : return ( self ,) return self . complex_factors def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" return ( \"QuadraticTrinomial({0!r}, {1!r}, {2!r})\" . format ( self . a , self . b , self . c ) )","title":"Module polynomial.trinomial"},{"location":"reference/polynomial/trinomial/#classes","text":"","title":"Classes"},{"location":"reference/polynomial/trinomial/#quadratictrinomial","text":"class QuadraticTrinomial ( a = 1 , b = 1 , c = 1 ) Implements quadratic trinomials and their related methods. View Source class QuadraticTrinomial ( FixedDegreePolynomial , Trinomial , valid_degrees = 2 ) : \"\"\"Implements quadratic trinomials and their related methods.\"\"\" def __init__ ( self , a = 1 , b = 1 , c = 1 ) : \"\"\"Initialize the trinomial as ax^2 + bx + c.\"\"\" if a == 0 : raise ValueError ( \"Object not a quadratic trinomial since a==0!\" ) Polynomial . __init__ ( self , a , b , c ) @property def discriminant ( self ) : \"\"\"Return the discriminant of ax^2 + bx + c = 0.\"\"\" c , b , a = self . _vector return b * b - 4 * a * c @property def complex_roots ( self ) : \"\"\"Return a 2-tuple with the 2 complex roots of ax^2 + bx + c = 0. + root is first, - root is second. \"\"\" c , b , a = self . _vector D = b * b - 4 * a * c sqrtD = sqrt ( D ) if D >= 0 else sqrt ( - D ) * 1 j a = a * 2 return ( - b + sqrtD ) / a , ( - b - sqrtD ) / a @property def real_roots ( self ) : \"\"\"Return a 2-tuple with the real roots if self.discriminant>=0. Return an empty tuple otherwise. \"\"\" if self . discriminant < 0 : return tuple () return self . complex_roots @property def complex_factors ( self ) : \"\"\"Return (a, (x-x_0), (x-x_1)), where x_0 and x_1 are the roots.\"\"\" roots = self . complex_roots return ( Constant ( self . a ), Polynomial ( [ 1, -roots[0 ] ] ), Polynomial ( [ 1, -roots[1 ] ] )) @property def real_factors ( self ) : \"\"\"Return (self,) if D < 0. Return the factors otherwise.\"\"\" if self . discriminant < 0 : return ( self ,) return self . complex_factors def __repr__ ( self ) : \"\"\"Return repr(self).\"\"\" return ( \"QuadraticTrinomial({0!r}, {1!r}, {2!r})\" . format ( self . a , self . b , self . c ) )","title":"QuadraticTrinomial"},{"location":"reference/polynomial/trinomial/#ancestors-in-mro","text":"polynomial.core.FixedDegreePolynomial polynomial.trinomial.Trinomial polynomial.core.FixedTermPolynomial polynomial.core.Polynomial","title":"Ancestors (in MRO)"},{"location":"reference/polynomial/trinomial/#class-variables","text":"valid_degrees valid_term_counts","title":"Class variables"},{"location":"reference/polynomial/trinomial/#static-methods","text":"","title":"Static methods"},{"location":"reference/polynomial/trinomial/#zero_instance","text":"def zero_instance ( ) Return the Polynomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial ()","title":"zero_instance"},{"location":"reference/polynomial/trinomial/#instance-variables","text":"complex_factors Return (a, (x-x_0), (x-x_1)), where x_0 and x_1 are the roots. complex_roots Return a 2-tuple with the 2 complex roots of ax^2 + bx + c = 0. root is first, - root is second. degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. discriminant Return the discriminant of ax^2 + bx + c = 0. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. real_factors Return (self,) if D < 0. Return the factors otherwise. real_roots Return a 2-tuple with the real roots if self.discriminant>=0. Return an empty tuple otherwise. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient.","title":"Instance variables"},{"location":"reference/polynomial/trinomial/#methods","text":"","title":"Methods"},{"location":"reference/polynomial/trinomial/#calculate","text":"def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms )","title":"calculate"},{"location":"reference/polynomial/trinomial/#nth_derivative","text":"def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] )","title":"nth_derivative"},{"location":"reference/polynomial/trinomial/#terms_are_valid","text":"def terms_are_valid ( self , terms ) View Source def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) )","title":"terms_are_valid"},{"location":"reference/polynomial/trinomial/#try_set_self","text":"def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True )","title":"try_set_self"},{"location":"reference/polynomial/trinomial/#trinomial","text":"class Trinomial ( monomial1 = None , monomial2 = None , monomial3 = None ) Implements single-variable mathematical trinomials. View Source class Trinomial ( FixedTermPolynomial , valid_term_counts = ( 0 , 1 , 2 , 3 )): \"\"\"Implements single-variable mathematical trinomials.\"\"\" def __init__ ( self , monomial1 = None , monomial2 = None , monomial3 = None ): \"\"\"Initialize the trinomial with 3 monomials. The arguments can also be 2-tuples in the form: (coefficient, degree) \"\"\" if not monomial1 : monomial1 = Monomial ( 1 , 1 ) if not monomial2 : monomial2 = Monomial ( 1 , 2 ) if not monomial3 : monomial3 = Monomial ( 1 , 3 ) args = [ monomial1 , monomial2 , monomial3 ] Polynomial . __init__ ( self , args , from_monomials = True ) def __repr__ ( self ): \"\"\"Return repr(self).\"\"\" terms = self . terms assert len ( terms ) == 3 t1 , t2 , t3 = terms return ( \"Trinomial(Monomial({0}, {1}), Monomial({2}, {3}), \" \"Monomial({4}, {5}))\" . format ( * t1 , * t2 , * t3 ) )","title":"Trinomial"},{"location":"reference/polynomial/trinomial/#ancestors-in-mro_1","text":"polynomial.core.FixedTermPolynomial polynomial.core.Polynomial","title":"Ancestors (in MRO)"},{"location":"reference/polynomial/trinomial/#descendants","text":"polynomial.trinomial.QuadraticTrinomial","title":"Descendants"},{"location":"reference/polynomial/trinomial/#class-variables_1","text":"valid_term_counts","title":"Class variables"},{"location":"reference/polynomial/trinomial/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/polynomial/trinomial/#zero_instance_1","text":"def zero_instance ( ) Return the Polynomial which is 0. View Source @classmethod def zero_instance ( cls ) : \"\"\"Return the Polynomial which is 0.\"\"\" return Polynomial ()","title":"zero_instance"},{"location":"reference/polynomial/trinomial/#instance-variables_1","text":"degree Return the degree of the polynomial. derivative Return a polynomial object which is the derivative of self. monomials Return a list with all terms in the form of monomials. List is sorted from the highest degree term to the lowest. terms Get the terms of self as a list of tuples in coeff, deg form. Terms are returned from largest degree to smallest degree, excluding any terms with a zero coefficient.","title":"Instance variables"},{"location":"reference/polynomial/trinomial/#methods_1","text":"","title":"Methods"},{"location":"reference/polynomial/trinomial/#calculate_1","text":"def calculate ( self , x ) Calculate the value of the polynomial at a given point. View Source def calculate ( self , x ): \"\"\"Calculate the value of the polynomial at a given point.\"\"\" if self . degree < 0 : return 0 return sum ( ak * ( x ** k ) for ak , k in self . terms )","title":"calculate"},{"location":"reference/polynomial/trinomial/#nth_derivative_1","text":"def nth_derivative ( self , n = 1 ) Return the polynomial object which is the nth derivative of self. View Source def nth_derivative ( self , n = 1 ) : \"\"\"Return the polynomial object which is the nth derivative of self.\"\"\" if not isinstance ( n , int ) or n < 0 : raise ValueError ( \"n must be a non-negative integer (got {0})\" . format ( n ) ) if not self or n > self . degree : # Short circuit since the result would be zero . return self . zero_instance () if n == 0 : return deepcopy ( self ) if n == 1 : factors = range ( 1 , self . degree + 1 ) else : d = self . degree - n + 1 factorial_term = n + 1 factors = [ 1 ] * d # Calculate n ! for base term . for i in range ( 1 , factorial_term ) : factors [ 0 ] *= i for i in range ( 1 , d ) : # The last number is n * ( n - 1 ) * ( n - 2 ) * ... * i # The next number is ( n + 1 ) * n * ( n - 1 ) * ... * i + 1 # To get the next number , we multiply the last number by # n + 1 and divide by i . factors [ i ] = ( factors [ i - 1 ] // i ) * factorial_term factorial_term += 1 return Polynomial ( [ c * x for c, x in zip(self, reversed(factors)) ] )","title":"nth_derivative"},{"location":"reference/polynomial/trinomial/#terms_are_valid_1","text":"def terms_are_valid ( self , terms ) View Source def terms_are_valid ( self , terms ): return ( _terms_are_valid ( self , terms ) and orig_terms_are_valid ( self , terms ) )","title":"terms_are_valid"},{"location":"reference/polynomial/trinomial/#try_set_self_1","text":"def try_set_self ( self , terms ) Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. View Source def try_set_self ( self , terms ): \"\"\"Try applying terms to self if possible. If not possible, returns a Polynomial with the terms. \"\"\" if self . terms_are_valid ( terms ): self . terms = terms return self return Polynomial ( terms , from_monomials = True )","title":"try_set_self"}]}